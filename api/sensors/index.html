
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://TannerTorrey3.github.io/DSG-JIT/api/sensors/">
      
      
        <link rel="prev" href="../slam/">
      
      
        <link rel="next" href="../optimization/">
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Sensors - DSG-JIT</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="deep-purple" data-md-color-accent="teal">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#sensor-modules" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="DSG-JIT" class="md-header__button md-logo" aria-label="DSG-JIT" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            DSG-JIT
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Sensors
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="deep-purple" data-md-color-accent="teal"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="teal"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/TannerTorrey3/DSG-JIT" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    TannerTorrey3/DSG-JIT
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="DSG-JIT" class="md-nav__button md-logo" aria-label="DSG-JIT" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    DSG-JIT
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/TannerTorrey3/DSG-JIT" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    TannerTorrey3/DSG-JIT
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../architecture/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Architecture
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../benchmarks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Benchmarks
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Examples
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../roadmap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Roadmap
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Glossary
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" checked>
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    
  
    API
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            
  
    API
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../core/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Core
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../slam/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    SLAM
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Sensors
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Sensors
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#sensorsbase" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.base
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="sensors.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.base--core-components" class="md-nav__link">
    <span class="md-ellipsis">
      
        Core Components
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.base--design-goals" class="md-nav__link">
    <span class="md-ellipsis">
      
        Design Goals
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.base--summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.base.BaseMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        BaseMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.base.Sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        Sensor
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Sensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.base.Sensor.build_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_factors
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.base.SensorReading" class="md-nav__link">
    <span class="md-ellipsis">
      
        SensorReading
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorscamera" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.camera
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.AsyncCamera" class="md-nav__link">
    <span class="md-ellipsis">
      
        AsyncCamera
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AsyncCamera">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.camera.AsyncCamera.frames" class="md-nav__link">
    <span class="md-ellipsis">
      
        frames
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.CameraFrame" class="md-nav__link">
    <span class="md-ellipsis">
      
        CameraFrame
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.CameraIntrinsics" class="md-nav__link">
    <span class="md-ellipsis">
      
        CameraIntrinsics
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.CameraMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        CameraMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.SyncCamera" class="md-nav__link">
    <span class="md-ellipsis">
      
        SyncCamera
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SyncCamera">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.camera.SyncCamera.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.is_gray" class="md-nav__link">
    <span class="md-ellipsis">
      
        is_gray
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.is_rgb" class="md-nav__link">
    <span class="md-ellipsis">
      
        is_rgb
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.to_grayscale" class="md-nav__link">
    <span class="md-ellipsis">
      
        to_grayscale
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.to_rgb" class="md-nav__link">
    <span class="md-ellipsis">
      
        to_rgb
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsconversion" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.conversion
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.MeasurementFactor" class="md-nav__link">
    <span class="md-ellipsis">
      
        MeasurementFactor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.RangeMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        RangeMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.apply_measurement_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        apply_measurement_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.bearing_to_factor" class="md-nav__link">
    <span class="md-ellipsis">
      
        bearing_to_factor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.camera_bearings_to_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        camera_bearings_to_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.camera_depth_to_points_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        camera_depth_to_points_sensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.imu_to_factors_placeholder" class="md-nav__link">
    <span class="md-ellipsis">
      
        imu_to_factors_placeholder
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.integrate_imu_delta" class="md-nav__link">
    <span class="md-ellipsis">
      
        integrate_imu_delta
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_measurement_to_voxel_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_measurement_to_voxel_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_scan_to_points_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_scan_to_points_sensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_scan_to_points_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_scan_to_points_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_scan_to_voxel_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_scan_to_voxel_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.measurement_factors_to_graph_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        measurement_factors_to_graph_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.pixel_to_ray_camera" class="md-nav__link">
    <span class="md-ellipsis">
      
        pixel_to_ray_camera
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.pixels_to_rays_camera" class="md-nav__link">
    <span class="md-ellipsis">
      
        pixels_to_rays_camera
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.range_1d_to_factor" class="md-nav__link">
    <span class="md-ellipsis">
      
        range_1d_to_factor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.range_to_point_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        range_to_point_sensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.range_to_point_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        range_to_point_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.raw_sample_to_camera_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        raw_sample_to_camera_measurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.raw_sample_to_imu_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        raw_sample_to_imu_measurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.raw_sample_to_lidar_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        raw_sample_to_lidar_measurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.voxel_point_obs_factor" class="md-nav__link">
    <span class="md-ellipsis">
      
        voxel_point_obs_factor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsfusion" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.fusion
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.fusion.FusedPoseEstimate" class="md-nav__link">
    <span class="md-ellipsis">
      
        FusedPoseEstimate
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.fusion.RegisteredSensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        RegisteredSensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager" class="md-nav__link">
    <span class="md-ellipsis">
      
        SensorFusionManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SensorFusionManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.attach_world_model" class="md-nav__link">
    <span class="md-ellipsis">
      
        attach_world_model
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.get_latest_pose" class="md-nav__link">
    <span class="md-ellipsis">
      
        get_latest_pose
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.poll_once" class="md-nav__link">
    <span class="md-ellipsis">
      
        poll_once
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.push_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        push_measurement
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.record_fused_pose" class="md-nav__link">
    <span class="md-ellipsis">
      
        record_fused_pose
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.register_callback" class="md-nav__link">
    <span class="md-ellipsis">
      
        register_callback
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.register_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        register_sensor
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsimu" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.imu
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.IMUMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        IMUMeasurement
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IMUMeasurement">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.imu.IMUMeasurement.as_numpy" class="md-nav__link">
    <span class="md-ellipsis">
      
        as_numpy
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.IMUSampleFn" class="md-nav__link">
    <span class="md-ellipsis">
      
        IMUSampleFn
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.IMUSensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        IMUSensor
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IMUSensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.imu.IMUSensor.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __iter__
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.imu.IMUSensor.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.integrate_imu_naive" class="md-nav__link">
    <span class="md-ellipsis">
      
        integrate_imu_naive
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsintegration" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.integration
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.integration.apply_fused_pose_to_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        apply_fused_pose_to_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.integration.apply_trajectory_to_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        apply_trajectory_to_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorslidar" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.lidar
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.lidar.LidarMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        LidarMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.lidar.RangeSensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        RangeSensor
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RangeSensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.lidar.RangeSensor.build_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_factors
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.lidar.RangeSensorConfig" class="md-nav__link">
    <span class="md-ellipsis">
      
        RangeSensorConfig
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsstreams" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.streams
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.AsyncFileRangeStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        AsyncFileRangeStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AsyncFileRangeStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.AsyncFileRangeStream.__aiter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __aiter__
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.AsyncReadingStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        AsyncReadingStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AsyncReadingStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.AsyncReadingStream.__aiter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __aiter__
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        BaseSensorStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseSensorStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream.__aiter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __aiter__
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream.close" class="md-nav__link">
    <span class="md-ellipsis">
      
        close
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.FileRangeStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        FileRangeStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FileRangeStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.FileRangeStream.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __iter__
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.FunctionStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        FunctionStream
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.ReadingStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        ReadingStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ReadingStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.ReadingStream.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __iter__
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.streams.ReadingStream.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../optimization/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Optimization
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../scene_graph/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Scene Graph
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../world/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    World Model
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../datasets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Datasets
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    
  
    Tutorials
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tutorials
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Introduction
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_2" >
        
          
          <label class="md-nav__link" for="__nav_8_2" id="__nav_8_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Core Concepts
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Core Concepts
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/mini_world/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Mini World Factor Graph
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/manifold_geometry_se3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Manifold Geometry SE(3)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scene_graph_world/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Building a Semantic Scene Graph World
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scene_graph_objects/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Working with Objects in Scene Graphs
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/differentiable_voxel_obs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Differentiable Voxel Observations
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/visual_factor_graph/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Visualizing a Factor Graph in 3D
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_3d/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3D Scene Graph Construction & Visualization
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Scene Graph Demo - Rooms, Places, Poses, and Objects
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/dynamic_scenegraph_demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Scene Graph Demo
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_3" >
        
          
          <label class="md-nav__link" for="__nav_8_3" id="__nav_8_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    SE(3) & SLAM
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    SE(3) & SLAM
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/manifold_geometry_se3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Manifold Geometry SE(3)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scene_graph_world/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Building a Semantic Scene Graph World
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/dynamic_trajectories/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Trajectories
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/differentiable_se3_odom_chain/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Differentiable SE(3) Odometry Chain
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_type_weights/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Learnable Factor-Type Weights in a Scene Graph
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_se3_voxel_joint_learning/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid SE(3) & Voxel Joint Parameter Learning
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_dsg/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid Differentiable Scene Graphs
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/visual_factor_graph/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Visualizing a Factor Graph in 3D
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_3d/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3D Scene Graph Construction & Visualization
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/dynamic_scenegraph_demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Scene Graph Demo
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/sliding_window/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Slidingâ€‘Window Optimization with Active Templates
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_4" >
        
          
          <label class="md-nav__link" for="__nav_8_4" id="__nav_8_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Voxel Grids & Spatial Fields
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Voxel Grids & Spatial Fields
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/differentiable_voxel_obs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Differentiable Voxel Observations
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/multi_voxel_param/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Multi-Voxel Parameter Optimization
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/trainer_voxel_point_multi/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Multi-Voxel Point Observation Learning
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/multi_voxel_param_weight/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Joint Learning of Voxel Observation Parameters & Type Weights
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_se3_voxel_joint_learning/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid SE(3) & Voxel Joint Parameter Learning
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_dsg/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid Differentiable Scene Graphs
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_5" >
        
          
          <label class="md-nav__link" for="__nav_8_5" id="__nav_8_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Static Scene Graphs
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Static Scene Graphs
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scene_graph_world/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Building a Semantic Scene Graph World
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scene_graph_objects/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Working with Objects in Scene Graphs
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scene_graph_objects_jit/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Scene Graph Objects (JIT)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/dynamic_trajectories/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Trajectories
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Scene Graph Demo - Rooms, Places, Poses, and Objects
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_6" >
        
          
          <label class="md-nav__link" for="__nav_8_6" id="__nav_8_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Scene Graphs
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    Dynamic Scene Graphs
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_type_weights/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Learnable Factor-Type Weights in a Scene Graph
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/trainer_voxel_point_multi/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Multi-Voxel Point Observation Learning
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_se3_voxel_joint_learning/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid SE(3) & Voxel Joint Parameter Learning
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_dsg/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid Differentiable Scene Graphs
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_3d/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3D Scene Graph Construction & Visualization
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/dynamic_scenegraph_demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Dynamic Scene Graph Demo
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/range_sensor_dsg/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Range Sensor Dynamic Scene Graph
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/sensor_dsg_mapping/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sensor DSG Mapping (End-to-End)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/sliding_window/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Slidingâ€‘Window Optimization with Active Templates
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_7" >
        
          
          <label class="md-nav__link" for="__nav_8_7" id="__nav_8_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Sensors & Fusion
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_7">
            <span class="md-nav__icon md-icon"></span>
            
  
    Sensors & Fusion
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/range_sensor_dsg/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Range Sensor Dynamic Scene Graph
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/sensor_fusion_demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sensor Fusion Sandbox - Camera, LiDAR, and IMU Streams
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/sensor_dsg_mapping/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Sensor DSG Mapping (End-to-End)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_8" >
        
          
          <label class="md-nav__link" for="__nav_8_8" id="__nav_8_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Learning & Hybrid Modules
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_8">
            <span class="md-nav__icon md-icon"></span>
            
  
    Learning & Hybrid Modules
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/multi_voxel_param/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Multi-Voxel Parameter Optimization
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/differentiable_se3_odom_chain/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Differentiable SE(3) Odometry Chain
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/learn_type_weights/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Learning Factor-Type Weights
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scenegraph_type_weights/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Learnable Factor-Type Weights in a Scene Graph
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/trainer_voxel_point_multi/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Multi-Voxel Point Observation Learning
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/multi_voxel_param_weight/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Joint Learning of Voxel Observation Parameters & Type Weights
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_se3_voxel_joint_learning/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid SE(3) & Voxel Joint Parameter Learning
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/hybrid_dsg/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Hybrid Differentiable Scene Graphs
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_9" >
        
          
          <label class="md-nav__link" for="__nav_8_9" id="__nav_8_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    JAX & JIT
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_9">
            <span class="md-nav__icon md-icon"></span>
            
  
    JAX & JIT
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/scene_graph_objects_jit/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Scene Graph Objects (JIT)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/differentiable_voxel_obs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Differentiable Voxel Observations
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/visual_factor_graph/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Visualizing a Factor Graph in 3D
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorials/sliding_window/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Slidingâ€‘Window Optimization with Active Templates
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#sensorsbase" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.base
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="sensors.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.base--core-components" class="md-nav__link">
    <span class="md-ellipsis">
      
        Core Components
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.base--design-goals" class="md-nav__link">
    <span class="md-ellipsis">
      
        Design Goals
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.base--summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.base.BaseMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        BaseMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.base.Sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        Sensor
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Sensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.base.Sensor.build_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_factors
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.base.SensorReading" class="md-nav__link">
    <span class="md-ellipsis">
      
        SensorReading
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorscamera" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.camera
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.AsyncCamera" class="md-nav__link">
    <span class="md-ellipsis">
      
        AsyncCamera
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AsyncCamera">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.camera.AsyncCamera.frames" class="md-nav__link">
    <span class="md-ellipsis">
      
        frames
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.CameraFrame" class="md-nav__link">
    <span class="md-ellipsis">
      
        CameraFrame
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.CameraIntrinsics" class="md-nav__link">
    <span class="md-ellipsis">
      
        CameraIntrinsics
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.CameraMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        CameraMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.SyncCamera" class="md-nav__link">
    <span class="md-ellipsis">
      
        SyncCamera
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SyncCamera">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.camera.SyncCamera.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.is_gray" class="md-nav__link">
    <span class="md-ellipsis">
      
        is_gray
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.is_rgb" class="md-nav__link">
    <span class="md-ellipsis">
      
        is_rgb
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.to_grayscale" class="md-nav__link">
    <span class="md-ellipsis">
      
        to_grayscale
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.camera.to_rgb" class="md-nav__link">
    <span class="md-ellipsis">
      
        to_rgb
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsconversion" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.conversion
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.MeasurementFactor" class="md-nav__link">
    <span class="md-ellipsis">
      
        MeasurementFactor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.RangeMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        RangeMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.apply_measurement_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        apply_measurement_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.bearing_to_factor" class="md-nav__link">
    <span class="md-ellipsis">
      
        bearing_to_factor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.camera_bearings_to_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        camera_bearings_to_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.camera_depth_to_points_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        camera_depth_to_points_sensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.imu_to_factors_placeholder" class="md-nav__link">
    <span class="md-ellipsis">
      
        imu_to_factors_placeholder
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.integrate_imu_delta" class="md-nav__link">
    <span class="md-ellipsis">
      
        integrate_imu_delta
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_measurement_to_voxel_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_measurement_to_voxel_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_scan_to_points_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_scan_to_points_sensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_scan_to_points_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_scan_to_points_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.lidar_scan_to_voxel_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        lidar_scan_to_voxel_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.measurement_factors_to_graph_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        measurement_factors_to_graph_factors
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.pixel_to_ray_camera" class="md-nav__link">
    <span class="md-ellipsis">
      
        pixel_to_ray_camera
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.pixels_to_rays_camera" class="md-nav__link">
    <span class="md-ellipsis">
      
        pixels_to_rays_camera
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.range_1d_to_factor" class="md-nav__link">
    <span class="md-ellipsis">
      
        range_1d_to_factor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.range_to_point_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        range_to_point_sensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.range_to_point_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        range_to_point_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.raw_sample_to_camera_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        raw_sample_to_camera_measurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.raw_sample_to_imu_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        raw_sample_to_imu_measurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.raw_sample_to_lidar_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        raw_sample_to_lidar_measurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.conversion.voxel_point_obs_factor" class="md-nav__link">
    <span class="md-ellipsis">
      
        voxel_point_obs_factor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsfusion" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.fusion
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.fusion.FusedPoseEstimate" class="md-nav__link">
    <span class="md-ellipsis">
      
        FusedPoseEstimate
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.fusion.RegisteredSensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        RegisteredSensor
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager" class="md-nav__link">
    <span class="md-ellipsis">
      
        SensorFusionManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SensorFusionManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.attach_world_model" class="md-nav__link">
    <span class="md-ellipsis">
      
        attach_world_model
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.get_latest_pose" class="md-nav__link">
    <span class="md-ellipsis">
      
        get_latest_pose
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.poll_once" class="md-nav__link">
    <span class="md-ellipsis">
      
        poll_once
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.push_measurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        push_measurement
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.record_fused_pose" class="md-nav__link">
    <span class="md-ellipsis">
      
        record_fused_pose
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.register_callback" class="md-nav__link">
    <span class="md-ellipsis">
      
        register_callback
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.fusion.SensorFusionManager.register_sensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        register_sensor
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsimu" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.imu
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.IMUMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        IMUMeasurement
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IMUMeasurement">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.imu.IMUMeasurement.as_numpy" class="md-nav__link">
    <span class="md-ellipsis">
      
        as_numpy
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.IMUSampleFn" class="md-nav__link">
    <span class="md-ellipsis">
      
        IMUSampleFn
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.IMUSensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        IMUSensor
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IMUSensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.imu.IMUSensor.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __iter__
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.imu.IMUSensor.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.imu.integrate_imu_naive" class="md-nav__link">
    <span class="md-ellipsis">
      
        integrate_imu_naive
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsintegration" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.integration
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.integration.apply_fused_pose_to_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        apply_fused_pose_to_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.integration.apply_trajectory_to_world" class="md-nav__link">
    <span class="md-ellipsis">
      
        apply_trajectory_to_world
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorslidar" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.lidar
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.lidar.LidarMeasurement" class="md-nav__link">
    <span class="md-ellipsis">
      
        LidarMeasurement
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.lidar.RangeSensor" class="md-nav__link">
    <span class="md-ellipsis">
      
        RangeSensor
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RangeSensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.lidar.RangeSensor.build_factors" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_factors
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.lidar.RangeSensorConfig" class="md-nav__link">
    <span class="md-ellipsis">
      
        RangeSensorConfig
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensorsstreams" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensors.streams
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.AsyncFileRangeStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        AsyncFileRangeStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AsyncFileRangeStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.AsyncFileRangeStream.__aiter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __aiter__
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.AsyncReadingStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        AsyncReadingStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AsyncReadingStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.AsyncReadingStream.__aiter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __aiter__
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        BaseSensorStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseSensorStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream.__aiter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __aiter__
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream.close" class="md-nav__link">
    <span class="md-ellipsis">
      
        close
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.streams.BaseSensorStream.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.FileRangeStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        FileRangeStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FileRangeStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.FileRangeStream.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __iter__
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.FunctionStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        FunctionStream
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sensors.streams.ReadingStream" class="md-nav__link">
    <span class="md-ellipsis">
      
        ReadingStream
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ReadingStream">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sensors.streams.ReadingStream.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      
        __iter__
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensors.streams.ReadingStream.read" class="md-nav__link">
    <span class="md-ellipsis">
      
        read
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="sensor-modules">Sensor Modules</h1>
<p>High-level sensor support for DSG-JIT. This package provides:</p>
<ul>
<li><strong>Lightweight measurement containers</strong>: camera, LiDAR, IMU.</li>
<li><strong>Streaming abstractions</strong> (<code>sensors.streams</code>) for synthetic or file-based data.</li>
<li><strong>Conversion utilities</strong> (<code>sensors.conversion</code>) from raw samples â†’ DSG-JIT measurements.</li>
<li><strong>Sensor fusion manager</strong> (<code>sensors.fusion.SensorFusionManager</code>) that:</li>
<li>Polls one or more sensor streams.</li>
<li>Converts them into measurements.</li>
<li>Optionally forwards them to <code>WorldModel</code> / <code>SceneGraphWorld</code> helpers.</li>
</ul>
<hr />
<h2 id="sensorsbase"><code>sensors.base</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Abstract base classes and shared interfaces for DSG-JIT sensor modules.</p>
<p>This module defines the foundational API that all sensor types in DSG-JIT
(IMU, LiDAR, RGB cameras, range sensors, etc.) are expected to implement.
By unifying the contract between sensor objects and the rest of the system,
DSG-JIT enables plug-and-play multi-sensor integration without requiring
special-case logic for each modality.</p>
<p>The goal of this module is to answer a simple question:</p>
<pre><code>â€œWhat does it mean to be a sensor in DSG-JIT?â€
</code></pre>
<hr />
<h3 id="sensors.base--core-components">Core Components</h3>
<p><strong>BaseSensor</strong>
    The abstract parent class for all sensors. It typically defines:</p>
<pre><code>  - ``initialize()``  â€” optional setup before streaming begins  
  - ``read()``        â€” return a *single typed measurement*  
  - ``close()``       â€” release hardware or simulation resources

Subclasses (e.g., ``IMUSensor``, ``LiDARSensor``, ``CameraSensor``)
implement their own measurement-specific logic, but all present
a consistent surface to the rest of DSG-JIT.
</code></pre>
<p><strong>BaseMeasurement</strong>
    A typed container for the output of a sensor.<br />
    Every measurement has:</p>
<pre><code>  - ``timestamp``  
  - device-specific payload (e.g., accelerations, images, point clouds)

The purpose of this common type is to make downstream modulesâ€”
factor graphs, dynamic scene graphs, training loops, logging toolsâ€”
treat all measurements uniformly.
</code></pre>
<hr />
<h3 id="sensors.base--design-goals">Design Goals</h3>
<ol>
<li>
<p><strong>Unified sensor API</strong><br />
   All sensors behave the same from the perspective of DSG-JITâ€™s
   world model, optimization routines, and streaming helpers.</p>
</li>
<li>
<p><strong>Compatibility with synchronous &amp; asynchronous streams</strong><br />
   The interfaces defined here are intentionally minimal so that
   <code>streams.py</code> can wrap <em>any</em> sensor using either Python loops or
   asyncio-based background tasks.</p>
</li>
<li>
<p><strong>Future-proof extensibility</strong><br />
   The goal is for users to implement custom sensors (GPS, UWB, RADAR,
   event cameras, tactile sensors, etc.) by subclassing
   <code>BaseSensor</code> and returning custom <code>BaseMeasurement</code> types.</p>
</li>
<li>
<p><strong>Separation of concerns</strong><br />
   This module defines <em>contracts</em>, not implementation logic.
   Sensor-specific math, calibration, conversion, or projection
   live in their respective modules (e.g., <code>lidar.py</code>, <code>camera.py</code>).</p>
</li>
</ol>
<hr />
<h3 id="sensors.base--summary">Summary</h3>
<p>The <code>base</code> module provides the essential abstraction layer required for
building robust, modular, multi-sensor dynamic scene graphs. It ensures that
all data entering DSG-JITâ€”regardless of modalityâ€”flows through a consistent,
well-structured interface suitable for high-frequency SLAM, perception,
and future real-time scene generation.</p>










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="sensors.base.BaseMeasurement" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">BaseMeasurement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Generic typed measurement used by all DSG-JIT sensor backends.</p>
<p>This class represents a single sensor sample emitted by a device or
by a stream wrapper. All concrete sensor measurement types
(e.g., :class:<code>CameraMeasurement</code>, :class:<code>LidarMeasurement</code>,
:class:<code>IMUMeasurement</code>) should inherit from this class.</p>
<p>:param t: Discrete timestamp or frame index associated with the sample.
:type t: int
:param source: Name of the sensor that produced this measurement
    (e.g., <code>"front_cam"</code>, <code>"lidar_0"</code>, <code>"imu_main"</code>).
:type source: str
:param data: Raw modality-specific payload. Subclasses may refine this type.
    For example, a camera may store an ndarray, LiDAR may store a point cloud,
    and IMU may store (accel, gyro) tuples.
:type data: Any
:param meta: Optional metadata, such as exposure time, pose hints, or flags.
:type meta: dict or None</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.base.Sensor" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">Sensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">agent_id</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">



        <p>Abstract base class for all DSG-JIT sensors.</p>
<p>Concrete subclasses implement :meth:<code>build_factors</code> to turn a
:class:<code>SensorReading</code> into one or more :class:<code>core.types.Factor</code>
instances, which can then be added to a :class:<code>world.model.WorldModel</code>.</p>
<p>Sensors are intended to be <em>stateless</em> with respect to optimization:
they describe how to map readings into factors, but do not own any
variables themselves.</p>
<p>Typical usage pattern::</p>
<pre><code>sensor = SomeSensor(agent_id="robot0", ...)
reading = SensorReading(t=3, data=raw_measurement)
factors = sensor.build_factors(world_model, dsg, reading)
for f in factors:
    world_model.fg.add_factor(f)
</code></pre>
<p>:param name: Human-readable name for this sensor instance.
:type name: str
:param agent_id: Identifier of the agent this sensor is mounted on,
    e.g. <code>"robot0"</code>. Used to resolve pose nodes in the DSG.
:type agent_id: str</p>








                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/base.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">agent_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">agent_id</span> <span class="o">=</span> <span class="n">agent_id</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.base.Sensor.build_factors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">build_factors</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">dsg</span><span class="p">,</span> <span class="n">reading</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Convert a sensor reading into factor(s) to be added to the world.</p>
<p>Subclasses must implement this to return a list of
:class:<code>core.types.Factor</code> objects whose <code>var_ids</code> and
<code>params</code> are consistent with the residuals registered in the
world's factor graph.</p>
<p>:param wm: World model into which new factors will be added.
:type wm: world.model.WorldModel
:param dsg: Dynamic scene graph providing access to pose node ids
    for this sensor's agent at the requested time index.
:type dsg: world.dynamic_scene_graph.DynamicSceneGraph
:param reading: Sensor reading to convert.
:type reading: SensorReading
:return: List of factor objects ready to be added to
    :attr:<code>wm.fg</code>.
:rtype: list[core.types.Factor]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/base.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_factors</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">wm</span><span class="p">:</span> <span class="n">WorldModel</span><span class="p">,</span>
    <span class="n">dsg</span><span class="p">:</span> <span class="n">DynamicSceneGraph</span><span class="p">,</span>
    <span class="n">reading</span><span class="p">:</span> <span class="n">SensorReading</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Factor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a sensor reading into factor(s) to be added to the world.</span>

<span class="sd">    Subclasses must implement this to return a list of</span>
<span class="sd">    :class:`core.types.Factor` objects whose ``var_ids`` and</span>
<span class="sd">    ``params`` are consistent with the residuals registered in the</span>
<span class="sd">    world&#39;s factor graph.</span>

<span class="sd">    :param wm: World model into which new factors will be added.</span>
<span class="sd">    :type wm: world.model.WorldModel</span>
<span class="sd">    :param dsg: Dynamic scene graph providing access to pose node ids</span>
<span class="sd">        for this sensor&#39;s agent at the requested time index.</span>
<span class="sd">    :type dsg: world.dynamic_scene_graph.DynamicSceneGraph</span>
<span class="sd">    :param reading: Sensor reading to convert.</span>
<span class="sd">    :type reading: SensorReading</span>
<span class="sd">    :return: List of factor objects ready to be added to</span>
<span class="sd">        :attr:`wm.fg`.</span>
<span class="sd">    :rtype: list[core.types.Factor]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.base.SensorReading" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">SensorReading</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Lightweight container for a single sensor measurement.</p>
<p>:param t: Discrete time index or timestamp at which the reading was
    taken. For now this is typically an integer matching the DSG's
    time index.
:type t: int
:param data: Raw or minimally processed sensor payload. The exact
    structure depends on the sensor type (e.g. a scalar range,
    a 3D point, an image array, etc.).
:type data: Any</p>











<div class="doc doc-children">












  </div>

    </div>

</div>




  </div>

    </div>

</div><hr />
<h2 id="sensorscamera"><code>sensors.camera</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Camera sensor abstractions and utilities for DSG-JIT.</p>
<p>This module defines lightweight, JAX-friendly camera interfaces that can be
plugged into dynamic scene graph (DSG) pipelines. The goal is to provide a
clean separation between:</p>
<ul>
<li><strong>Raw image acquisition</strong> (e.g., from a hardware driver, simulator, or
    prerecorded dataset), and</li>
<li><strong>Downstream SLAM / DSG consumers</strong> that only need structured frames
    (RGB or grayscale) with timestamps and metadata.</li>
</ul>
<p>The module typically exposes:</p>
<ul>
<li>
<p><code>CameraFrame</code>:
      A simple dataclass-like structure representing a single image frame.
      It usually stores image data (RGB or grayscale), optional depth, and
      a timestamp or frame index.</p>
</li>
<li>
<p><code>CameraSensor</code>:
      A wrapper around an arbitrary user-provided capture function. The
      capture function may return NumPy arrays or JAX arrays; the wrapper
      normalizes these and provides a consistent interface for reading
      frames in synchronous loops or via the generic sensor streams.</p>
</li>
<li>
<p>Optional utilities for:</p>
<ul>
<li>Converting RGB frames to grayscale.</li>
<li>Normalizing/typing images for consumption by JAX or downstream
    vision modules.</li>
<li>Integrating with the generic sensor streaming API (synchronous or
    asynchronous).</li>
</ul>
</li>
</ul>
<p>These camera abstractions are intentionally minimal and do <em>not</em> perform
full visual odometry or object detection. Instead, they are designed as
building blocks for higher-level modules (e.g., visual SLAM, semantic
DSG layers) that can interpret camera data and inject new nodes and
factors into the scene graph or factor graph.</p>
<p>The design philosophy is:</p>
<ul>
<li>Keep camera handling <strong>stateless</strong> where possible.</li>
<li>Make it easy to wrap <em>any</em> existing camera source (OpenCV, ROS, custom
    simulator, etc.) behind a small capture function.</li>
<li>Ensure that integration with DSG-JIT remains explicit and composable,
    so users can swap cameras or add multiple sensors without changing
    core SLAM logic.</li>
</ul>










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="sensors.camera.AsyncCamera" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">AsyncCamera</span><span class="p">(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">aiter_fn</span><span class="p">,</span> <span class="n">color_space</span><span class="o">=</span><span class="s1">&#39;rgb&#39;</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Asynchronous camera source.</p>
<p>:param intrinsics: Camera intrinsics.
:param aiter_fn: Callable that returns an async iterator yielding images as numpy arrays.
:param color_space: Color space of the images produced by aiter_fn, default is "rgb".</p>











<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.camera.AsyncCamera.frames" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">frames</span><span class="p">()</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Asynchronously iterate over frames from the camera.</p>
<p>:returns: An async iterator yielding CameraFrame objects with current timestamp, no frame_id, and the configured color_space.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/camera.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">frames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">CameraFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Asynchronously iterate over frames from the camera.</span>

<span class="sd">    :returns: An async iterator yielding CameraFrame objects with current timestamp, no frame_id, and the configured color_space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aiter_fn</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">CameraFrame</span><span class="p">(</span>
            <span class="n">image</span><span class="o">=</span><span class="n">img</span><span class="p">,</span>
            <span class="n">timestamp</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
            <span class="n">frame_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">color_space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">color_space</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.camera.CameraFrame" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">CameraFrame</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">frame_id</span><span class="p">,</span> <span class="n">color_space</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>A single camera frame.</p>
<p>:param image: The image array.
:param timestamp: Timestamp of the frame capture.
:param frame_id: Optional frame identifier.
:param color_space: Color space of the image, either "rgb" or "gray".</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.camera.CameraIntrinsics" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">CameraIntrinsics</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Pinhole camera intrinsics.</p>
<p>:param width: Image width in pixels.
:param height: Image height in pixels.
:param fx: Focal length in x direction.
:param fy: Focal length in y direction.
:param cx: Principal point x coordinate.
:param cy: Principal point y coordinate.</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.camera.CameraMeasurement" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">CameraMeasurement</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">sensor_id</span><span class="o">=</span><span class="s1">&#39;cam0&#39;</span><span class="p">,</span> <span class="n">T_cam_body</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>High-level camera measurement suitable for feeding into SLAM / DSG layers.</p>
<p>This wraps a low-level :class:<code>CameraFrame</code> with additional metadata
such as sensor ID, extrinsics, and an optional sequence index. It is
intentionally minimal and can be extended by applications as needed.</p>
<p>:param frame:
    The underlying camera frame (image, timestamp, color space, etc.).
:param sensor_id:
    Identifier for the camera (e.g., <code>"cam0"</code>). Useful when multiple
    cameras are present.
:param T_cam_body:
    Optional 4x4 homogeneous transform from body frame to camera frame.
    If omitted, downstream consumers may assume an identity transform or
    use a configured default.
:param seq:
    Optional sequence index (e.g., frame counter) for convenience.
:param metadata:
    Optional free-form dictionary for extra information
    (exposure, gain, rolling-shutter parameters, etc.).</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.camera.SyncCamera" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">SyncCamera</span><span class="p">(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">read_fn</span><span class="p">,</span> <span class="n">color_space</span><span class="o">=</span><span class="s1">&#39;rgb&#39;</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Synchronous camera source.</p>
<p>:param intrinsics: Camera intrinsics.
:param read_fn: Callable that returns an image as a numpy array.
:param color_space: Color space of the images produced by read_fn, default is "rgb".</p>











<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.camera.SyncCamera.read" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">read</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a single frame from the camera.</p>
<p>:returns: A CameraFrame containing the image, current timestamp, no frame_id, and the configured color_space.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/camera.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CameraFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a single frame from the camera.</span>

<span class="sd">    :returns: A CameraFrame containing the image, current timestamp, no frame_id, and the configured color_space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_fn</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">CameraFrame</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="n">img</span><span class="p">,</span>
        <span class="n">timestamp</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
        <span class="n">frame_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">color_space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">color_space</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="sensors.camera.is_gray" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">is_gray</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Check if the frame is in grayscale color space.</p>
<p>:param frame: The camera frame to check.
:returns: True if the frame's color space is one of "gray", "grey", or "grayscale" (case-insensitive), False otherwise.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/camera.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_gray</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CameraFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the frame is in grayscale color space.</span>

<span class="sd">    :param frame: The camera frame to check.</span>
<span class="sd">    :returns: True if the frame&#39;s color space is one of &quot;gray&quot;, &quot;grey&quot;, or &quot;grayscale&quot; (case-insensitive), False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">frame</span><span class="o">.</span><span class="n">color_space</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="s2">&quot;grey&quot;</span><span class="p">,</span> <span class="s2">&quot;grayscale&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.camera.is_rgb" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">is_rgb</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Check if the frame is in RGB color space.</p>
<p>:param frame: The camera frame to check.
:returns: True if the frame's color space is "rgb" (case-insensitive), False otherwise.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/camera.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_rgb</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CameraFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the frame is in RGB color space.</span>

<span class="sd">    :param frame: The camera frame to check.</span>
<span class="sd">    :returns: True if the frame&#39;s color space is &quot;rgb&quot; (case-insensitive), False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">frame</span><span class="o">.</span><span class="n">color_space</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.camera.to_grayscale" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to_grayscale</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert an RGB frame to grayscale. If the frame is already grayscale, returns it unchanged.</p>
<p>For RGB frames, assumes image shape is (H, W, 3) and applies standard luminance weights [0.299, 0.587, 0.114]
to convert to grayscale with shape (H, W). The returned image is float32 in [0, 1] if the input was uint8.</p>
<p>:param frame: The input camera frame.
:returns: A new CameraFrame in grayscale color space with the same timestamp and frame_id.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/camera.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_grayscale</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CameraFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CameraFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an RGB frame to grayscale. If the frame is already grayscale, returns it unchanged.</span>

<span class="sd">    For RGB frames, assumes image shape is (H, W, 3) and applies standard luminance weights [0.299, 0.587, 0.114]</span>
<span class="sd">    to convert to grayscale with shape (H, W). The returned image is float32 in [0, 1] if the input was uint8.</span>

<span class="sd">    :param frame: The input camera frame.</span>
<span class="sd">    :returns: A new CameraFrame in grayscale color space with the same timestamp and frame_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_gray</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">frame</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>
    <span class="n">gray_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.299</span><span class="p">,</span> <span class="mf">0.587</span><span class="p">,</span> <span class="mf">0.114</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">CameraFrame</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="n">gray_img</span><span class="p">,</span>
        <span class="n">timestamp</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
        <span class="n">frame_id</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_id</span><span class="p">,</span>
        <span class="n">color_space</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.camera.to_rgb" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to_rgb</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a grayscale frame to RGB by stacking the gray channel three times along the last axis.
If the frame is already RGB, returns it unchanged.</p>
<p>:param frame: The input camera frame.
:returns: A new CameraFrame in RGB color space with the same timestamp and frame_id.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/camera.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_rgb</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CameraFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CameraFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a grayscale frame to RGB by stacking the gray channel three times along the last axis.</span>
<span class="sd">    If the frame is already RGB, returns it unchanged.</span>

<span class="sd">    :param frame: The input camera frame.</span>
<span class="sd">    :returns: A new CameraFrame in RGB color space with the same timestamp and frame_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_rgb</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">frame</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">img</span>
    <span class="k">return</span> <span class="n">CameraFrame</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="n">rgb_img</span><span class="p">,</span>
        <span class="n">timestamp</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
        <span class="n">frame_id</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_id</span><span class="p">,</span>
        <span class="n">color_space</span><span class="o">=</span><span class="s2">&quot;rgb&quot;</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="sensorsconversion"><code>sensors.conversion</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Conversion utilities from sensor measurements to factor-graph factors.</p>
<p>This module implements the "measurement conversion layer" for DSG-JIT: given
typed sensor measurements (IMU, LiDAR, cameras, simple range sensors, etc.),
it produces factor descriptions that can be attached to the core
:class:<code>core.factor_graph.FactorGraph</code> or to higher-level world/scene-graph
abstractions.</p>
<p>The core idea is to keep sensor-facing code and factor-graph-facing code
decoupled:</p>
<ul>
<li>Sensor modules (<code>sensors.camera</code>, <code>sensors.imu</code>, <code>sensors.lidar</code>,
  <code>sensors.streams</code>, â€¦) produce strongly-typed measurement objects.</li>
<li>
<p>This module converts those measurements into small
  :class:<code>MeasurementFactor</code> records describing:</p>
<ul>
<li><code>factor_type</code> (string key for the residual)</li>
<li><code>var_ids</code> (tuple of variable node ids to connect)</li>
<li><code>params</code> (dictionary passed into the residual function)</li>
</ul>
</li>
</ul>
<p>Downstream code can then:</p>
<ul>
<li>Construct :class:<code>core.types.Factor</code> objects from these records.</li>
<li>Call :meth:<code>core.factor_graph.FactorGraph.add_factor</code>.</li>
<li>Or wrap them in higher-level helpers in :mod:<code>world.scene_graph</code>.</li>
</ul>
<p>This keeps sensor integration "plug-and-play" while preserving a clean,
minimal interface for the optimization engine.</p>










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="sensors.conversion.MeasurementFactor" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">MeasurementFactor</span><span class="p">(</span><span class="n">factor_type</span><span class="p">,</span> <span class="n">var_ids</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Lightweight description of a factor generated from a sensor measurement.</p>
<p>This is intentionally decoupled from :class:<code>core.types.Factor</code> so that
the conversion layer does not depend on internal factor-graph details.
Call :func:<code>measurement_factors_to_graph_factors</code> to turn these into
concrete :class:<code>Factor</code> instances, or use
:func:<code>apply_measurement_factors</code> to add them directly to a
:class:<code>FactorGraph</code>.</p>
<p>:param factor_type: String key for the residual function
    (e.g. <code>"range_1d"</code>, <code>"pose_landmark_bearing"</code>,
    <code>"voxel_point_obs"</code>, etc.). This must correspond to a type
    previously registered via
    :meth:<code>core.factor_graph.FactorGraph.register_residual</code>.
:type factor_type: str
:param var_ids: Tuple of variable node ids that this factor connects,
    in the order expected by the residual function.
:type var_ids: tuple[int, ...]
:param params: Parameter dictionary passed into the residual function.
    Entries are typically NumPy/JAX arrays or scalar floats
    (e.g. <code>{"measurement": ..., "sigma": ...}</code>).
:type params: dict[str, Any]</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.conversion.RangeMeasurement" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">RangeMeasurement</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">ray_dir</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Simple 1D range measurement along a known unit ray.</p>
<p>:param distance: Measured distance along the ray, in meters.
:param ray_dir: Unit direction vector in the sensor frame, shape (3,).</p>











<div class="doc doc-children">












  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.apply_measurement_factors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_measurement_factors</span><span class="p">(</span><span class="n">fg</span><span class="p">,</span> <span class="n">meas_factors</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Add a sequence of measurement-derived factors to a factor graph.</p>
<p>This is a thin convenience wrapper around
:func:<code>measurement_factors_to_graph_factors</code> and
:meth:<code>core.factor_graph.FactorGraph.add_factor</code>.</p>
<p>:param fg: The factor graph to which the new factors should be added.
:type fg: FactorGraph
:param meas_factors: Iterable of :class:<code>MeasurementFactor</code> objects.
:type meas_factors: Iterable[MeasurementFactor]
:return: This function has no return value; it mutates <code>fg</code> in-place
    by adding new factors.
:rtype: None</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_measurement_factors</span><span class="p">(</span>
    <span class="n">fg</span><span class="p">:</span> <span class="n">FactorGraph</span><span class="p">,</span>
    <span class="n">meas_factors</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a sequence of measurement-derived factors to a factor graph.</span>

<span class="sd">    This is a thin convenience wrapper around</span>
<span class="sd">    :func:`measurement_factors_to_graph_factors` and</span>
<span class="sd">    :meth:`core.factor_graph.FactorGraph.add_factor`.</span>

<span class="sd">    :param fg: The factor graph to which the new factors should be added.</span>
<span class="sd">    :type fg: FactorGraph</span>
<span class="sd">    :param meas_factors: Iterable of :class:`MeasurementFactor` objects.</span>
<span class="sd">    :type meas_factors: Iterable[MeasurementFactor]</span>
<span class="sd">    :return: This function has no return value; it mutates ``fg`` in-place</span>
<span class="sd">        by adding new factors.</span>
<span class="sd">    :rtype: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">measurement_factors_to_graph_factors</span><span class="p">(</span><span class="n">meas_factors</span><span class="p">):</span>
        <span class="n">fg</span><span class="o">.</span><span class="n">add_factor</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.bearing_to_factor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">bearing_to_factor</span><span class="p">(</span><span class="n">pose_id</span><span class="p">,</span> <span class="n">landmark_id</span><span class="p">,</span> <span class="n">bearing_vec</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">factor_type</span><span class="o">=</span><span class="s1">&#39;pose_landmark_bearing&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a bearing vector to a factor description.</p>
<p>This is suitable for camera-like observations where you have a unit
bearing vector from the camera pose to a landmark in either camera
or world coordinates, and a residual function that enforces angular
consistency between the predicted bearing and the measured one.</p>
<p>:param pose_id: Node id of the camera/pose variable.
:type pose_id: int
:param landmark_id: Node id of the landmark/point variable.
:type landmark_id: int
:param bearing_vec: Measured bearing direction as a vector. This
    should typically be normalized (unit length) and have shape
    <code>(2,)</code> or <code>(3,)</code>, depending on the residual implementation.
:type bearing_vec: jax.numpy.ndarray
:param sigma: Measurement noise standard deviation in angular units
    (radians or an equivalent bearing metric).
:type sigma: float
:param factor_type: String key for the residual function (e.g.
    <code>"pose_landmark_bearing"</code>). Must match a registered factor
    type in the :class:<code>FactorGraph</code>.
:type factor_type: str
:return: A :class:<code>MeasurementFactor</code> describing the bearing
    constraint.
:rtype: MeasurementFactor</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">bearing_to_factor</span><span class="p">(</span>
    <span class="n">pose_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">landmark_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">bearing_vec</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">factor_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pose_landmark_bearing&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MeasurementFactor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a bearing vector to a factor description.</span>

<span class="sd">    This is suitable for camera-like observations where you have a unit</span>
<span class="sd">    bearing vector from the camera pose to a landmark in either camera</span>
<span class="sd">    or world coordinates, and a residual function that enforces angular</span>
<span class="sd">    consistency between the predicted bearing and the measured one.</span>

<span class="sd">    :param pose_id: Node id of the camera/pose variable.</span>
<span class="sd">    :type pose_id: int</span>
<span class="sd">    :param landmark_id: Node id of the landmark/point variable.</span>
<span class="sd">    :type landmark_id: int</span>
<span class="sd">    :param bearing_vec: Measured bearing direction as a vector. This</span>
<span class="sd">        should typically be normalized (unit length) and have shape</span>
<span class="sd">        ``(2,)`` or ``(3,)``, depending on the residual implementation.</span>
<span class="sd">    :type bearing_vec: jax.numpy.ndarray</span>
<span class="sd">    :param sigma: Measurement noise standard deviation in angular units</span>
<span class="sd">        (radians or an equivalent bearing metric).</span>
<span class="sd">    :type sigma: float</span>
<span class="sd">    :param factor_type: String key for the residual function (e.g.</span>
<span class="sd">        ``&quot;pose_landmark_bearing&quot;``). Must match a registered factor</span>
<span class="sd">        type in the :class:`FactorGraph`.</span>
<span class="sd">    :type factor_type: str</span>
<span class="sd">    :return: A :class:`MeasurementFactor` describing the bearing</span>
<span class="sd">        constraint.</span>
<span class="sd">    :rtype: MeasurementFactor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bearing_vec</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bearing_vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;bearing_meas&quot;</span><span class="p">:</span> <span class="n">bearing_vec</span><span class="p">,</span>
        <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">MeasurementFactor</span><span class="p">(</span>
        <span class="n">factor_type</span><span class="o">=</span><span class="n">factor_type</span><span class="p">,</span>
        <span class="n">var_ids</span><span class="o">=</span><span class="p">(</span><span class="n">pose_id</span><span class="p">,</span> <span class="n">landmark_id</span><span class="p">),</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.camera_bearings_to_factors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">camera_bearings_to_factors</span><span class="p">(</span><span class="n">pose_id</span><span class="p">,</span> <span class="n">landmark_ids</span><span class="p">,</span> <span class="n">measurement</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">factor_type</span><span class="o">=</span><span class="s1">&#39;pose_landmark_bearing&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a :class:<code>sensors.camera.CameraMeasurement</code> containing bearing
directions into a list of measurement factors.</p>
<p>This helper assumes that the camera front-end has already extracted
unit bearing vectors from image data (e.g. via feature detection and
calibration), and that these bearings have been associated with a set
of landmark ids. For each <code>landmark_id</code> and corresponding row in
<code>measurement.bearings</code>, we construct a bearing factor using
:func:<code>bearing_to_factor</code>.</p>
<p>:param pose_id: Node id of the camera/pose variable in the factor graph.
:type pose_id: int
:param landmark_ids: Sequence of landmark node ids, one per bearing
    vector in <code>measurement.bearings</code>.
:type landmark_ids: Sequence[int]
:param measurement: Camera measurement containing an array of bearing
    vectors in <code>measurement.bearings</code> with shape <code>(N, D)</code> where
    <code>D</code> is typically 2 or 3.
:type measurement: CameraMeasurement
:param sigma: Bearing noise standard deviation passed through to
    :func:<code>bearing_to_factor</code>.
:type sigma: float
:param factor_type: Factor type string for the bearing residual,
    usually <code>"pose_landmark_bearing"</code>.
:type factor_type: str
:return: List of :class:<code>MeasurementFactor</code> objects, one per
    (pose, landmark) bearing observation.
:rtype: list[MeasurementFactor]
:raises ValueError: If the number of landmark ids does not match the
    number of bearing vectors stored in the measurement.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">camera_bearings_to_factors</span><span class="p">(</span>
    <span class="n">pose_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">landmark_ids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">measurement</span><span class="p">:</span> <span class="n">CameraMeasurement</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">factor_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pose_landmark_bearing&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a :class:`sensors.camera.CameraMeasurement` containing bearing</span>
<span class="sd">    directions into a list of measurement factors.</span>

<span class="sd">    This helper assumes that the camera front-end has already extracted</span>
<span class="sd">    unit bearing vectors from image data (e.g. via feature detection and</span>
<span class="sd">    calibration), and that these bearings have been associated with a set</span>
<span class="sd">    of landmark ids. For each ``landmark_id`` and corresponding row in</span>
<span class="sd">    ``measurement.bearings``, we construct a bearing factor using</span>
<span class="sd">    :func:`bearing_to_factor`.</span>

<span class="sd">    :param pose_id: Node id of the camera/pose variable in the factor graph.</span>
<span class="sd">    :type pose_id: int</span>
<span class="sd">    :param landmark_ids: Sequence of landmark node ids, one per bearing</span>
<span class="sd">        vector in ``measurement.bearings``.</span>
<span class="sd">    :type landmark_ids: Sequence[int]</span>
<span class="sd">    :param measurement: Camera measurement containing an array of bearing</span>
<span class="sd">        vectors in ``measurement.bearings`` with shape ``(N, D)`` where</span>
<span class="sd">        ``D`` is typically 2 or 3.</span>
<span class="sd">    :type measurement: CameraMeasurement</span>
<span class="sd">    :param sigma: Bearing noise standard deviation passed through to</span>
<span class="sd">        :func:`bearing_to_factor`.</span>
<span class="sd">    :type sigma: float</span>
<span class="sd">    :param factor_type: Factor type string for the bearing residual,</span>
<span class="sd">        usually ``&quot;pose_landmark_bearing&quot;``.</span>
<span class="sd">    :type factor_type: str</span>
<span class="sd">    :return: List of :class:`MeasurementFactor` objects, one per</span>
<span class="sd">        (pose, landmark) bearing observation.</span>
<span class="sd">    :rtype: list[MeasurementFactor]</span>
<span class="sd">    :raises ValueError: If the number of landmark ids does not match the</span>
<span class="sd">        number of bearing vectors stored in the measurement.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bearings</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">measurement</span><span class="o">.</span><span class="n">bearings</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bearings</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;measurement.bearings must have shape (N, D), got </span><span class="si">{</span><span class="n">bearings</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">landmark_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bearings</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;len(landmark_ids)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">landmark_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;measurement.bearings.shape[0]=</span><span class="si">{</span><span class="n">bearings</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">factors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">landmark_ids</span><span class="p">,</span> <span class="n">bearings</span><span class="p">):</span>
        <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">bearing_to_factor</span><span class="p">(</span>
                <span class="n">pose_id</span><span class="o">=</span><span class="n">pose_id</span><span class="p">,</span>
                <span class="n">landmark_id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">lid</span><span class="p">),</span>
                <span class="n">bearing_vec</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                <span class="n">factor_type</span><span class="o">=</span><span class="n">factor_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">factors</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.camera_depth_to_points_sensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">camera_depth_to_points_sensor</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a depth image into a 3D point cloud in the camera frame.</p>
<p>The depth image is assumed to have the same width/height as specified
by the camera intrinsics. For each pixel <code>(u, v)</code> with depth <code>d</code>,
we compute a ray via :func:<code>pixel_to_ray_camera</code> and place the point
at <code>d * ray</code>.</p>
<p>:param cam: Camera measurement with intrinsics.
:param depth: Depth map of shape <code>(H, W)</code> in meters.
:returns: Array of points of shape <code>(H*W, 3)</code> in the camera frame.
    Invalid or zero depths are skipped.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">camera_depth_to_points_sensor</span><span class="p">(</span>
    <span class="n">cam</span><span class="p">:</span> <span class="n">CameraMeasurement</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a depth image into a 3D point cloud in the camera frame.</span>

<span class="sd">    The depth image is assumed to have the same width/height as specified</span>
<span class="sd">    by the camera intrinsics. For each pixel ``(u, v)`` with depth ``d``,</span>
<span class="sd">    we compute a ray via :func:`pixel_to_ray_camera` and place the point</span>
<span class="sd">    at ``d * ray``.</span>

<span class="sd">    :param cam: Camera measurement with intrinsics.</span>
<span class="sd">    :param depth: Depth map of shape ``(H, W)`` in meters.</span>
<span class="sd">    :returns: Array of points of shape ``(H*W, 3)`` in the camera frame.</span>
<span class="sd">        Invalid or zero depths are skipped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">depth</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ray</span> <span class="o">=</span> <span class="n">pixel_to_ray_camera</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">ray</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">points</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.imu_to_factors_placeholder" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">imu_to_factors_placeholder</span><span class="p">(</span><span class="n">pose_ids</span><span class="p">,</span> <span class="n">imu_meas</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Placeholder conversion from IMU measurement to factor descriptions.</p>
<p>In a full SLAM system, IMU data is typically handled via <em>preintegration</em>
over multiple high-rate samples to produce a single inertial factor
between two poses. That logic is non-trivial and highly application
specific, so this function serves as a placeholder and example.</p>
<p>For now, it returns an empty list and is intended to be replaced with
a proper preintegration pipeline in future work.</p>
<p>:param pose_ids: Sequence of pose node ids between which an IMU factor
    would be created (e.g. previous pose id and current pose id).
:type pose_ids: Sequence[int]
:param imu_meas: A single IMU measurement containing accelerometer and
    gyroscope readings along with a timestamp.
:type imu_meas: IMUMeasurement
:return: An empty list. Replace with application-specific IMU factor
    generation as needed.
:rtype: list[MeasurementFactor]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">imu_to_factors_placeholder</span><span class="p">(</span>
    <span class="n">pose_ids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">imu_meas</span><span class="p">:</span> <span class="n">IMUMeasurement</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Placeholder conversion from IMU measurement to factor descriptions.</span>

<span class="sd">    In a full SLAM system, IMU data is typically handled via *preintegration*</span>
<span class="sd">    over multiple high-rate samples to produce a single inertial factor</span>
<span class="sd">    between two poses. That logic is non-trivial and highly application</span>
<span class="sd">    specific, so this function serves as a placeholder and example.</span>

<span class="sd">    For now, it returns an empty list and is intended to be replaced with</span>
<span class="sd">    a proper preintegration pipeline in future work.</span>

<span class="sd">    :param pose_ids: Sequence of pose node ids between which an IMU factor</span>
<span class="sd">        would be created (e.g. previous pose id and current pose id).</span>
<span class="sd">    :type pose_ids: Sequence[int]</span>
<span class="sd">    :param imu_meas: A single IMU measurement containing accelerometer and</span>
<span class="sd">        gyroscope readings along with a timestamp.</span>
<span class="sd">    :type imu_meas: IMUMeasurement</span>
<span class="sd">    :return: An empty list. Replace with application-specific IMU factor</span>
<span class="sd">        generation as needed.</span>
<span class="sd">    :rtype: list[MeasurementFactor]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">pose_ids</span><span class="p">,</span> <span class="n">imu_meas</span>  <span class="c1"># avoid unused variable warnings</span>
    <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.integrate_imu_delta" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">integrate_imu_delta</span><span class="p">(</span><span class="n">imu</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">gravity</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Integrate a single IMU sample into a small SE(3) increment (se(3) vector).</p>
<p>This is a <strong>very</strong> simple, single-step integrator meant as a starting
point / placeholder. For real applications, a proper preintegration
scheme or filter should be used instead.</p>
<p>The returned 6D vector is in the form::</p>
<pre><code>[dtx, dty, dtz, drx, dry, drz]
</code></pre>
<p>where <code>dt*</code> is the approximate translational displacement in the IMU
frame and <code>dr*</code> is a small-angle approximation for the rotation.</p>
<p>:param imu: IMU measurement containing linear acceleration and angular
    velocity in the sensor frame.
:param dt: Time step in seconds between this sample and the previous one.
:param gravity: Optional gravity vector (in sensor frame). If provided,
    it is subtracted from the measured acceleration before integration.
    If <code>None</code>, no gravity compensation is performed.
:returns: A length-6 JAX array representing a small SE(3) increment in
    the IMU frame.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">integrate_imu_delta</span><span class="p">(</span>
    <span class="n">imu</span><span class="p">:</span> <span class="n">IMUMeasurement</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">gravity</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrate a single IMU sample into a small SE(3) increment (se(3) vector).</span>

<span class="sd">    This is a **very** simple, single-step integrator meant as a starting</span>
<span class="sd">    point / placeholder. For real applications, a proper preintegration</span>
<span class="sd">    scheme or filter should be used instead.</span>

<span class="sd">    The returned 6D vector is in the form::</span>

<span class="sd">        [dtx, dty, dtz, drx, dry, drz]</span>

<span class="sd">    where ``dt*`` is the approximate translational displacement in the IMU</span>
<span class="sd">    frame and ``dr*`` is a small-angle approximation for the rotation.</span>

<span class="sd">    :param imu: IMU measurement containing linear acceleration and angular</span>
<span class="sd">        velocity in the sensor frame.</span>
<span class="sd">    :param dt: Time step in seconds between this sample and the previous one.</span>
<span class="sd">    :param gravity: Optional gravity vector (in sensor frame). If provided,</span>
<span class="sd">        it is subtracted from the measured acceleration before integration.</span>
<span class="sd">        If ``None``, no gravity compensation is performed.</span>
<span class="sd">    :returns: A length-6 JAX array representing a small SE(3) increment in</span>
<span class="sd">        the IMU frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imu</span><span class="o">.</span><span class="n">accel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">gyro</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imu</span><span class="o">.</span><span class="n">gyro</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gravity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gravity</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gravity</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">-</span> <span class="n">gravity</span>

    <span class="c1"># Very crude single-step integration:</span>
    <span class="c1">#   v â‰ˆ a * dt</span>
    <span class="c1">#   p â‰ˆ 0.5 * a * dt^2</span>
    <span class="c1">#   Î¸ â‰ˆ Ï‰ * dt</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">acc</span> <span class="o">*</span> <span class="p">(</span><span class="n">dt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">dtheta</span> <span class="o">=</span> <span class="n">gyro</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">dp</span><span class="p">,</span> <span class="n">dtheta</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.lidar_measurement_to_voxel_factors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">lidar_measurement_to_voxel_factors</span><span class="p">(</span><span class="n">measurement</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">factor_type</span><span class="o">=</span><span class="s1">&#39;voxel_point_obs&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a :class:<code>sensors.lidar.LidarMeasurement</code> into voxel-point
observation factors.</p>
<p>This helper assumes that the LiDAR front-end has already projected raw
ranges into 3D world coordinates and, optionally, associated each
point with a voxel id. If <code>measurement.voxel_ids</code> is provided, it is
used directly; otherwise, the caller is expected to supply voxel
associations separately.</p>
<p>Concretely, this is a thin wrapper around
:func:<code>lidar_scan_to_voxel_factors</code>, using
<code>measurement.points_world</code> and <code>measurement.voxel_ids</code>.</p>
<p>:param measurement: LiDAR measurement containing a point cloud in
    world coordinates and optional voxel assignments.
:type measurement: LidarMeasurement
:param sigma: Noise level for each point in world units, forwarded to
    :func:<code>voxel_point_obs_factor</code>.
:type sigma: float
:param factor_type: Factor type string used for all voxel-point
    factors, typically <code>"voxel_point_obs"</code>.
:type factor_type: str
:return: List of :class:<code>MeasurementFactor</code> objects describing the
    LiDAR point cloud constraints.
:rtype: list[MeasurementFactor]
:raises ValueError: If <code>measurement.voxel_ids</code> is <code>None</code> or its
    length does not match the number of points.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lidar_measurement_to_voxel_factors</span><span class="p">(</span>
    <span class="n">measurement</span><span class="p">:</span> <span class="n">LidarMeasurement</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">factor_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;voxel_point_obs&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a :class:`sensors.lidar.LidarMeasurement` into voxel-point</span>
<span class="sd">    observation factors.</span>

<span class="sd">    This helper assumes that the LiDAR front-end has already projected raw</span>
<span class="sd">    ranges into 3D world coordinates and, optionally, associated each</span>
<span class="sd">    point with a voxel id. If ``measurement.voxel_ids`` is provided, it is</span>
<span class="sd">    used directly; otherwise, the caller is expected to supply voxel</span>
<span class="sd">    associations separately.</span>

<span class="sd">    Concretely, this is a thin wrapper around</span>
<span class="sd">    :func:`lidar_scan_to_voxel_factors`, using</span>
<span class="sd">    ``measurement.points_world`` and ``measurement.voxel_ids``.</span>

<span class="sd">    :param measurement: LiDAR measurement containing a point cloud in</span>
<span class="sd">        world coordinates and optional voxel assignments.</span>
<span class="sd">    :type measurement: LidarMeasurement</span>
<span class="sd">    :param sigma: Noise level for each point in world units, forwarded to</span>
<span class="sd">        :func:`voxel_point_obs_factor`.</span>
<span class="sd">    :type sigma: float</span>
<span class="sd">    :param factor_type: Factor type string used for all voxel-point</span>
<span class="sd">        factors, typically ``&quot;voxel_point_obs&quot;``.</span>
<span class="sd">    :type factor_type: str</span>
<span class="sd">    :return: List of :class:`MeasurementFactor` objects describing the</span>
<span class="sd">        LiDAR point cloud constraints.</span>
<span class="sd">    :rtype: list[MeasurementFactor]</span>
<span class="sd">    :raises ValueError: If ``measurement.voxel_ids`` is ``None`` or its</span>
<span class="sd">        length does not match the number of points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points_world</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">measurement</span><span class="o">.</span><span class="n">points_world</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points_world</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;measurement.points_world must have shape (N, 3), got </span><span class="si">{</span><span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">measurement</span><span class="o">.</span><span class="n">voxel_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;measurement.voxel_ids is None; voxel associations are required &quot;</span>
            <span class="s2">&quot;to build voxel-point factors.&quot;</span>
        <span class="p">)</span>

    <span class="n">voxel_ids_seq</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">measurement</span><span class="o">.</span><span class="n">voxel_ids</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">voxel_ids_seq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;len(measurement.voxel_ids)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel_ids_seq</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;measurement.points_world.shape[0]=</span><span class="si">{</span><span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">lidar_scan_to_voxel_factors</span><span class="p">(</span>
        <span class="n">voxel_ids</span><span class="o">=</span><span class="n">voxel_ids_seq</span><span class="p">,</span>
        <span class="n">points_world</span><span class="o">=</span><span class="n">points_world</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
        <span class="n">factor_type</span><span class="o">=</span><span class="n">factor_type</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.lidar_scan_to_points_sensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">lidar_scan_to_points_sensor</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a planar LiDAR scan into 3D points in the sensor frame.</p>
<p>This function assumes a 2D planar LiDAR mounted in the <code>x-y</code> plane,
with all points lying at <code>z=0</code> in the sensor frame::</p>
<pre><code>x = r * cos(theta)
y = r * sin(theta)
z = 0
</code></pre>
<p>:param scan: LiDAR measurement containing per-beam ranges and angles.
:returns: Array of points of shape <code>(N, 3)</code> in the sensor frame.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lidar_scan_to_points_sensor</span><span class="p">(</span>
    <span class="n">scan</span><span class="p">:</span> <span class="n">LidarMeasurement</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a planar LiDAR scan into 3D points in the sensor frame.</span>

<span class="sd">    This function assumes a 2D planar LiDAR mounted in the ``x-y`` plane,</span>
<span class="sd">    with all points lying at ``z=0`` in the sensor frame::</span>

<span class="sd">        x = r * cos(theta)</span>
<span class="sd">        y = r * sin(theta)</span>
<span class="sd">        z = 0</span>

<span class="sd">    :param scan: LiDAR measurement containing per-beam ranges and angles.</span>
<span class="sd">    :returns: Array of points of shape ``(N, 3)`` in the sensor frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scan</span><span class="o">.</span><span class="n">ranges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scan</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">ranges</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">ranges</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.lidar_scan_to_points_world" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">lidar_scan_to_points_world</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="n">T_world_sensor</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a planar LiDAR scan into 3D points in world coordinates.</p>
<p>:param scan: LiDAR measurement in the sensor frame.
:param T_world_sensor: Homogeneous transform from sensor to world,
    shape <code>(4, 4)</code>.
:returns: Array of points of shape <code>(N, 3)</code> in world coordinates.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lidar_scan_to_points_world</span><span class="p">(</span>
    <span class="n">scan</span><span class="p">:</span> <span class="n">LidarMeasurement</span><span class="p">,</span>
    <span class="n">T_world_sensor</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a planar LiDAR scan into 3D points in world coordinates.</span>

<span class="sd">    :param scan: LiDAR measurement in the sensor frame.</span>
<span class="sd">    :param T_world_sensor: Homogeneous transform from sensor to world,</span>
<span class="sd">        shape ``(4, 4)``.</span>
<span class="sd">    :returns: Array of points of shape ``(N, 3)`` in world coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pts_s</span> <span class="o">=</span> <span class="n">lidar_scan_to_points_sensor</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span>  <span class="c1"># (N, 3)</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">pts_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">pts_s_h</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pts_s</span><span class="p">,</span> <span class="n">ones</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (N, 4)</span>
    <span class="n">pts_w_h</span> <span class="o">=</span> <span class="p">(</span><span class="n">T_world_sensor</span> <span class="o">@</span> <span class="n">pts_s_h</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># (N, 4)</span>
    <span class="k">return</span> <span class="n">pts_w_h</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.lidar_scan_to_voxel_factors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">lidar_scan_to_voxel_factors</span><span class="p">(</span><span class="n">voxel_ids</span><span class="p">,</span> <span class="n">points_world</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">factor_type</span><span class="o">=</span><span class="s1">&#39;voxel_point_obs&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a LiDAR point cloud into per-voxel observation factors.</p>
<p>This helper assumes that a pre-processing step has already:</p>
<ul>
<li>Projected the LiDAR ranges into 3D points in world coordinates.</li>
<li>Associated each point with a voxel id (e.g. via a voxel grid index).</li>
</ul>
<p>Given a list of voxel node ids and a matching array of 3D points,
this function returns one :class:<code>MeasurementFactor</code> per point.</p>
<p>:param voxel_ids: Iterable of voxel node ids, one per point.
:type voxel_ids: Sequence[int]
:param points_world: Array of 3D points in world coordinates with
    shape <code>(N, 3)</code>, where <code>N == len(voxel_ids)</code>.
:type points_world: jax.numpy.ndarray
:param sigma: Noise level for each point in world units.
:type sigma: float
:param factor_type: Factor type string used for all voxel-point
    factors, typically <code>"voxel_point_obs"</code>.
:type factor_type: str
:return: A list of :class:<code>MeasurementFactor</code> objects, one for each
    point/voxel pair.
:rtype: list[MeasurementFactor]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lidar_scan_to_voxel_factors</span><span class="p">(</span>
    <span class="n">voxel_ids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">points_world</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">factor_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;voxel_point_obs&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a LiDAR point cloud into per-voxel observation factors.</span>

<span class="sd">    This helper assumes that a pre-processing step has already:</span>

<span class="sd">    * Projected the LiDAR ranges into 3D points in world coordinates.</span>
<span class="sd">    * Associated each point with a voxel id (e.g. via a voxel grid index).</span>

<span class="sd">    Given a list of voxel node ids and a matching array of 3D points,</span>
<span class="sd">    this function returns one :class:`MeasurementFactor` per point.</span>

<span class="sd">    :param voxel_ids: Iterable of voxel node ids, one per point.</span>
<span class="sd">    :type voxel_ids: Sequence[int]</span>
<span class="sd">    :param points_world: Array of 3D points in world coordinates with</span>
<span class="sd">        shape ``(N, 3)``, where ``N == len(voxel_ids)``.</span>
<span class="sd">    :type points_world: jax.numpy.ndarray</span>
<span class="sd">    :param sigma: Noise level for each point in world units.</span>
<span class="sd">    :type sigma: float</span>
<span class="sd">    :param factor_type: Factor type string used for all voxel-point</span>
<span class="sd">        factors, typically ``&quot;voxel_point_obs&quot;``.</span>
<span class="sd">    :type factor_type: str</span>
<span class="sd">    :return: A list of :class:`MeasurementFactor` objects, one for each</span>
<span class="sd">        point/voxel pair.</span>
<span class="sd">    :rtype: list[MeasurementFactor]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points_world</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points_world</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points_world</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;points_world must have shape (N, 3), got </span><span class="si">{</span><span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">voxel_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;voxel_ids length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;points_world.shape[0] </span><span class="si">{</span><span class="n">points_world</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">factors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vid</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">voxel_ids</span><span class="p">,</span> <span class="n">points_world</span><span class="p">):</span>
        <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">voxel_point_obs_factor</span><span class="p">(</span>
                <span class="n">voxel_id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">vid</span><span class="p">),</span>
                <span class="n">point_world</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                <span class="n">factor_type</span><span class="o">=</span><span class="n">factor_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">factors</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.measurement_factors_to_graph_factors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">measurement_factors_to_graph_factors</span><span class="p">(</span><span class="n">meas_factors</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a sequence of :class:<code>MeasurementFactor</code> objects to concrete
:class:<code>core.types.Factor</code> instances.</p>
<p>Unique factor ids are generated using a simple running index; if you
need stable ids, you can post-process the factors or construct
them manually instead.</p>
<p>:param meas_factors: Iterable of :class:<code>MeasurementFactor</code> objects
    returned by the conversion helpers in this module.
:type meas_factors: Iterable[MeasurementFactor]
:return: A list of :class:<code>Factor</code> instances suitable for adding to
    a :class:<code>FactorGraph</code>.
:rtype: list[Factor]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">measurement_factors_to_graph_factors</span><span class="p">(</span>
    <span class="n">meas_factors</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">MeasurementFactor</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Factor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a sequence of :class:`MeasurementFactor` objects to concrete</span>
<span class="sd">    :class:`core.types.Factor` instances.</span>

<span class="sd">    Unique factor ids are generated using a simple running index; if you</span>
<span class="sd">    need stable ids, you can post-process the factors or construct</span>
<span class="sd">    them manually instead.</span>

<span class="sd">    :param meas_factors: Iterable of :class:`MeasurementFactor` objects</span>
<span class="sd">        returned by the conversion helpers in this module.</span>
<span class="sd">    :type meas_factors: Iterable[MeasurementFactor]</span>
<span class="sd">    :return: A list of :class:`Factor` instances suitable for adding to</span>
<span class="sd">        a :class:`FactorGraph`.</span>
<span class="sd">    :rtype: list[Factor]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph_factors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Factor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas_factors</span><span class="p">):</span>
        <span class="n">fid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;meas_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">graph_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">Factor</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">fid</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">mf</span><span class="o">.</span><span class="n">factor_type</span><span class="p">,</span>
                <span class="n">var_ids</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">var_ids</span><span class="p">),</span>
                <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">params</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">graph_factors</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.pixel_to_ray_camera" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">pixel_to_ray_camera</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a pixel coordinate into a normalized ray in the camera frame.</p>
<p>The intrinsics are assumed to follow the usual pinhole model::</p>
<pre><code>x = (u - cx) / fx
y = (v - cy) / fy
ray_cam = [x, y, 1]
ray_cam /= ||ray_cam||
</code></pre>
<p>:param cam: Camera measurement object providing intrinsics.
:param u: Pixel x-coordinate (column index).
:param v: Pixel y-coordinate (row index).
:returns: A unit 3D vector (shape <code>(3,)</code>) in the camera frame.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">pixel_to_ray_camera</span><span class="p">(</span>
    <span class="n">cam</span><span class="p">:</span> <span class="n">CameraMeasurement</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a pixel coordinate into a normalized ray in the camera frame.</span>

<span class="sd">    The intrinsics are assumed to follow the usual pinhole model::</span>

<span class="sd">        x = (u - cx) / fx</span>
<span class="sd">        y = (v - cy) / fy</span>
<span class="sd">        ray_cam = [x, y, 1]</span>
<span class="sd">        ray_cam /= ||ray_cam||</span>

<span class="sd">    :param cam: Camera measurement object providing intrinsics.</span>
<span class="sd">    :param u: Pixel x-coordinate (column index).</span>
<span class="sd">    :param v: Pixel y-coordinate (row index).</span>
<span class="sd">    :returns: A unit 3D vector (shape ``(3,)``) in the camera frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cam</span><span class="o">.</span><span class="n">intrinsics</span><span class="o">.</span><span class="n">fx</span><span class="p">)</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cam</span><span class="o">.</span><span class="n">intrinsics</span><span class="o">.</span><span class="n">fy</span><span class="p">)</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cam</span><span class="o">.</span><span class="n">intrinsics</span><span class="o">.</span><span class="n">cx</span><span class="p">)</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cam</span><span class="o">.</span><span class="n">intrinsics</span><span class="o">.</span><span class="n">cy</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">cx</span><span class="p">)</span> <span class="o">/</span> <span class="n">fx</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">cy</span><span class="p">)</span> <span class="o">/</span> <span class="n">fy</span>
    <span class="n">ray</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">ray</span> <span class="o">=</span> <span class="n">ray</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ray</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ray</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.pixels_to_rays_camera" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">pixels_to_rays_camera</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">pixels</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a collection of pixel coordinates into rays in the camera frame.</p>
<p>:param cam: Camera measurement object providing intrinsics.
:param pixels: Iterable of <code>(u, v)</code> pixel coordinates.
:returns: Array of unit 3D vectors of shape <code>(N, 3)</code> in the camera frame.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">pixels_to_rays_camera</span><span class="p">(</span>
    <span class="n">cam</span><span class="p">:</span> <span class="n">CameraMeasurement</span><span class="p">,</span>
    <span class="n">pixels</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a collection of pixel coordinates into rays in the camera frame.</span>

<span class="sd">    :param cam: Camera measurement object providing intrinsics.</span>
<span class="sd">    :param pixels: Iterable of ``(u, v)`` pixel coordinates.</span>
<span class="sd">    :returns: Array of unit 3D vectors of shape ``(N, 3)`` in the camera frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rays</span> <span class="o">=</span> <span class="p">[</span><span class="n">pixel_to_ray_camera</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">rays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.range_1d_to_factor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">range_1d_to_factor</span><span class="p">(</span><span class="n">pose_id</span><span class="p">,</span> <span class="n">place_id</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">factor_type</span><span class="o">=</span><span class="s1">&#39;range_1d&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a scalar range measurement (1D) into a factor description.</p>
<p>This is the generic bridge used by simple range sensors (e.g. the
1D range DSG experiment), where you have:</p>
<pre><code>pose_x - place_x â‰ˆ distance
</code></pre>
<p>and a residual function of type <code>factor_type</code> that expects a
<code>"measurement"</code> and optionally a <code>"sigma"</code> or <code>"weight"</code> in
its parameter dictionary.</p>
<p>:param pose_id: Node id of the pose variable in the factor graph.
:type pose_id: int
:param place_id: Node id of the place or landmark variable in the
    factor graph.
:type place_id: int
:param distance: Measured distance between the pose and the place.
:type distance: float
:param sigma: Measurement noise standard deviation. If your residual
    uses <code>weight</code> instead, you can convert this using
    <code>1.0 / (sigma ** 2)</code> when creating the factor.
:type sigma: float
:param factor_type: String key for the residual function. This must
    match a factor type registered into the :class:<code>FactorGraph</code>,
    for example <code>"range_1d"</code>.
:type factor_type: str
:return: A :class:<code>MeasurementFactor</code> describing the range constraint.
:rtype: MeasurementFactor</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">range_1d_to_factor</span><span class="p">(</span>
    <span class="n">pose_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">place_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">factor_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;range_1d&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MeasurementFactor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a scalar range measurement (1D) into a factor description.</span>

<span class="sd">    This is the generic bridge used by simple range sensors (e.g. the</span>
<span class="sd">    1D range DSG experiment), where you have:</span>

<span class="sd">        pose_x - place_x â‰ˆ distance</span>

<span class="sd">    and a residual function of type ``factor_type`` that expects a</span>
<span class="sd">    ``&quot;measurement&quot;`` and optionally a ``&quot;sigma&quot;`` or ``&quot;weight&quot;`` in</span>
<span class="sd">    its parameter dictionary.</span>

<span class="sd">    :param pose_id: Node id of the pose variable in the factor graph.</span>
<span class="sd">    :type pose_id: int</span>
<span class="sd">    :param place_id: Node id of the place or landmark variable in the</span>
<span class="sd">        factor graph.</span>
<span class="sd">    :type place_id: int</span>
<span class="sd">    :param distance: Measured distance between the pose and the place.</span>
<span class="sd">    :type distance: float</span>
<span class="sd">    :param sigma: Measurement noise standard deviation. If your residual</span>
<span class="sd">        uses ``weight`` instead, you can convert this using</span>
<span class="sd">        ``1.0 / (sigma ** 2)`` when creating the factor.</span>
<span class="sd">    :type sigma: float</span>
<span class="sd">    :param factor_type: String key for the residual function. This must</span>
<span class="sd">        match a factor type registered into the :class:`FactorGraph`,</span>
<span class="sd">        for example ``&quot;range_1d&quot;``.</span>
<span class="sd">    :type factor_type: str</span>
<span class="sd">    :return: A :class:`MeasurementFactor` describing the range constraint.</span>
<span class="sd">    :rtype: MeasurementFactor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;measurement&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">MeasurementFactor</span><span class="p">(</span>
        <span class="n">factor_type</span><span class="o">=</span><span class="n">factor_type</span><span class="p">,</span>
        <span class="n">var_ids</span><span class="o">=</span><span class="p">(</span><span class="n">pose_id</span><span class="p">,</span> <span class="n">place_id</span><span class="p">),</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.range_to_point_sensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">range_to_point_sensor</span><span class="p">(</span><span class="n">m</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a range measurement into a 3D point in the sensor frame.</p>
<p>:param m: Range measurement with a scalar distance and unit ray direction
    in the sensor frame.
:returns: A 3D point (shape <code>(3,)</code>) in the sensor frame.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">range_to_point_sensor</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">RangeMeasurement</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a range measurement into a 3D point in the sensor frame.</span>

<span class="sd">    :param m: Range measurement with a scalar distance and unit ray direction</span>
<span class="sd">        in the sensor frame.</span>
<span class="sd">    :returns: A 3D point (shape ``(3,)``) in the sensor frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
    <span class="n">dir_s</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">ray_dir</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">dir_s</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.range_to_point_world" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">range_to_point_world</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">T_world_sensor</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a range measurement into a 3D point in world coordinates.</p>
<p>This assumes you already have the sensor pose <code>T_world_sensor</code> as a
homogeneous transform matrix of shape <code>(4, 4)</code>. The point is first
constructed in the sensor frame and then transformed into the world.</p>
<p>:param m: Range measurement in the sensor frame.
:param T_world_sensor: Homogeneous transform from sensor to world,
    shape <code>(4, 4)</code>.
:returns: A 3D point (shape <code>(3,)</code>) in world coordinates.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">range_to_point_world</span><span class="p">(</span>
    <span class="n">m</span><span class="p">:</span> <span class="n">RangeMeasurement</span><span class="p">,</span>
    <span class="n">T_world_sensor</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a range measurement into a 3D point in world coordinates.</span>

<span class="sd">    This assumes you already have the sensor pose ``T_world_sensor`` as a</span>
<span class="sd">    homogeneous transform matrix of shape ``(4, 4)``. The point is first</span>
<span class="sd">    constructed in the sensor frame and then transformed into the world.</span>

<span class="sd">    :param m: Range measurement in the sensor frame.</span>
<span class="sd">    :param T_world_sensor: Homogeneous transform from sensor to world,</span>
<span class="sd">        shape ``(4, 4)``.</span>
<span class="sd">    :returns: A 3D point (shape ``(3,)``) in world coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p_s</span> <span class="o">=</span> <span class="n">range_to_point_sensor</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">p_s_h</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">p_s</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">p_w_h</span> <span class="o">=</span> <span class="n">T_world_sensor</span> <span class="o">@</span> <span class="n">p_s_h</span>
    <span class="k">return</span> <span class="n">p_w_h</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.raw_sample_to_camera_measurement" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">raw_sample_to_camera_measurement</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">sensor_id</span><span class="o">=</span><span class="s1">&#39;cam0&#39;</span><span class="p">,</span> <span class="n">T_cam_body</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a raw camera sample dictionary into a CameraMeasurement.</p>
<p>Expected keys in <code>sample</code>:</p>
<ul>
<li><code>"t"</code> (optional): float timestamp. If missing, the current time is used.</li>
<li><code>"frame_id"</code> (optional): string frame identifier.</li>
<li>ONE of the following image-like entries (optional):<ul>
<li><code>"image"</code>: (H, W) or (H, W, 3) array-like.</li>
</ul>
</li>
<li>Optional directional data (for feature-based SLAM):<ul>
<li><code>"bearings"</code>: (N, 3) array-like of unit directions.</li>
<li><code>"dirs"</code>: (N, 3) array-like.</li>
<li><code>"rays"</code>: (N, 3) array-like.</li>
</ul>
</li>
</ul>
<p>Any directional data is stored in the returned measurement's <code>metadata</code>
under the corresponding key (e.g. <code>metadata["bearings"]</code>).</p>
<p>:param sample:
    Raw sample dictionary produced by a sensor stream (e.g. ReadingStream
    or FunctionStream) in the experiments.
:param sensor_id:
    Identifier for this camera (e.g. <code>"cam0"</code>).
:param T_cam_body:
    Optional 4x4 homogeneous transform from body frame to camera frame.
:param seq:
    Optional sequence index (frame counter).</p>
<p>:returns:
    A :class:<code>CameraMeasurement</code> containing a :class:<code>CameraFrame</code> plus
    any directional data in the <code>metadata</code> field.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">raw_sample_to_camera_measurement</span><span class="p">(</span>
    <span class="n">sample</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">sensor_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cam0&quot;</span><span class="p">,</span>
    <span class="n">T_cam_body</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CameraMeasurement</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a raw camera sample dictionary into a CameraMeasurement.</span>

<span class="sd">    Expected keys in ``sample``:</span>

<span class="sd">    - ``&quot;t&quot;`` (optional): float timestamp. If missing, the current time is used.</span>
<span class="sd">    - ``&quot;frame_id&quot;`` (optional): string frame identifier.</span>
<span class="sd">    - ONE of the following image-like entries (optional):</span>
<span class="sd">        * ``&quot;image&quot;``: (H, W) or (H, W, 3) array-like.</span>
<span class="sd">    - Optional directional data (for feature-based SLAM):</span>
<span class="sd">        * ``&quot;bearings&quot;``: (N, 3) array-like of unit directions.</span>
<span class="sd">        * ``&quot;dirs&quot;``: (N, 3) array-like.</span>
<span class="sd">        * ``&quot;rays&quot;``: (N, 3) array-like.</span>

<span class="sd">    Any directional data is stored in the returned measurement&#39;s ``metadata``</span>
<span class="sd">    under the corresponding key (e.g. ``metadata[&quot;bearings&quot;]``).</span>

<span class="sd">    :param sample:</span>
<span class="sd">        Raw sample dictionary produced by a sensor stream (e.g. ReadingStream</span>
<span class="sd">        or FunctionStream) in the experiments.</span>
<span class="sd">    :param sensor_id:</span>
<span class="sd">        Identifier for this camera (e.g. ``&quot;cam0&quot;``).</span>
<span class="sd">    :param T_cam_body:</span>
<span class="sd">        Optional 4x4 homogeneous transform from body frame to camera frame.</span>
<span class="sd">    :param seq:</span>
<span class="sd">        Optional sequence index (frame counter).</span>

<span class="sd">    :returns:</span>
<span class="sd">        A :class:`CameraMeasurement` containing a :class:`CameraFrame` plus</span>
<span class="sd">        any directional data in the ``metadata`` field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Timestamp / frame id</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
    <span class="n">frame_id</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;frame_id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Image (optional)</span>
    <span class="k">if</span> <span class="s2">&quot;image&quot;</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If no image is present, create a dummy 1x1 grayscale image.</span>
        <span class="c1"># This lets us still pass a valid CameraFrame downstream.</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Decide color space from shape</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">color_space</span> <span class="o">=</span> <span class="s2">&quot;rgb&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">color_space</span> <span class="o">=</span> <span class="s2">&quot;gray&quot;</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="n">CameraFrame</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="n">img</span><span class="p">,</span>
        <span class="n">timestamp</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
        <span class="n">frame_id</span><span class="o">=</span><span class="n">frame_id</span><span class="p">,</span>
        <span class="n">color_space</span><span class="o">=</span><span class="n">color_space</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Collect directional data (bearings, dirs, rays) into metadata</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;bearings&quot;</span><span class="p">,</span> <span class="s2">&quot;dirs&quot;</span><span class="p">,</span> <span class="s2">&quot;rays&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">:</span>
            <span class="n">metadata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="c1"># Optionally keep any other extra keys under metadata[&quot;extra&quot;]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sample</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_id&quot;</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;bearings&quot;</span><span class="p">,</span> <span class="s2">&quot;dirs&quot;</span><span class="p">,</span> <span class="s2">&quot;rays&quot;</span><span class="p">):</span>
            <span class="n">metadata</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;extra&quot;</span><span class="p">,</span> <span class="p">{})[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">metadata</span><span class="p">:</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># keep clean if there is nothing to store</span>

    <span class="k">return</span> <span class="n">CameraMeasurement</span><span class="p">(</span>
        <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span>
        <span class="n">sensor_id</span><span class="o">=</span><span class="n">sensor_id</span><span class="p">,</span>
        <span class="n">T_cam_body</span><span class="o">=</span><span class="n">T_cam_body</span><span class="p">,</span>
        <span class="n">seq</span><span class="o">=</span><span class="n">seq</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.raw_sample_to_imu_measurement" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">raw_sample_to_imu_measurement</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a raw dict from a stream into an IMUMeasurement.</p>
<p>Expected keys in <code>sample</code>:</p>
<ul>
<li>"t": float timestamp (seconds).</li>
<li>"accel": array-like linear acceleration in the IMU frame.</li>
<li>"gyro": array-like angular velocity in the IMU frame.</li>
<li>"dt" (optional): time step in seconds since the previous sample.
  If omitted, a default value is used.</li>
</ul>
<p>:param sample: Raw sample dictionary produced by a sensor stream.
:return: An :class:<code>IMUMeasurement</code> instance.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">raw_sample_to_imu_measurement</span><span class="p">(</span><span class="n">sample</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">IMUMeasurement</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a raw dict from a stream into an IMUMeasurement.</span>

<span class="sd">    Expected keys in ``sample``:</span>

<span class="sd">    - &quot;t&quot;: float timestamp (seconds).</span>
<span class="sd">    - &quot;accel&quot;: array-like linear acceleration in the IMU frame.</span>
<span class="sd">    - &quot;gyro&quot;: array-like angular velocity in the IMU frame.</span>
<span class="sd">    - &quot;dt&quot; (optional): time step in seconds since the previous sample.</span>
<span class="sd">      If omitted, a default value is used.</span>

<span class="sd">    :param sample: Raw sample dictionary produced by a sensor stream.</span>
<span class="sd">    :return: An :class:`IMUMeasurement` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">accel</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s2">&quot;accel&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">gyro</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s2">&quot;gyro&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Use provided dt if available, otherwise fall back to a reasonable default</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dt&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">IMUMeasurement</span><span class="p">(</span>
        <span class="n">timestamp</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
        <span class="n">accel</span><span class="o">=</span><span class="n">accel</span><span class="p">,</span>
        <span class="n">gyro</span><span class="o">=</span><span class="n">gyro</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.raw_sample_to_lidar_measurement" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">raw_sample_to_lidar_measurement</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a raw LiDAR sample dictionary into a :class:<code>LidarMeasurement</code>.</p>
<p>Expected keys in <code>sample</code>:</p>
<ul>
<li><code>"ranges"</code>: 1D array-like of LiDAR ranges. (required)</li>
<li><code>"angles"</code>: 1D array-like of bearing angles (radians), same length as <code>ranges</code>. (optional)</li>
<li><code>"directions"</code>: (N, 3) array-like of direction vectors. (optional)</li>
<li><code>"t"</code> (optional): float timestamp.</li>
<li><code>"frame_id"</code> (optional): string frame identifier.</li>
</ul>
<p>This is consistent with the rest of the LiDAR utilities in this module,
which assume a planar LiDAR described by <code>ranges</code> and <code>angles</code>.</p>
<p>:param sample: Raw sample dictionary produced by a sensor stream.
:returns: A :class:<code>LidarMeasurement</code> instance.
:raises KeyError: If required keys are missing from the sample.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">raw_sample_to_lidar_measurement</span><span class="p">(</span><span class="n">sample</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">LidarMeasurement</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a raw LiDAR sample dictionary into a :class:`LidarMeasurement`.</span>

<span class="sd">    Expected keys in ``sample``:</span>

<span class="sd">    - ``&quot;ranges&quot;``: 1D array-like of LiDAR ranges. (required)</span>
<span class="sd">    - ``&quot;angles&quot;``: 1D array-like of bearing angles (radians), same length as ``ranges``. (optional)</span>
<span class="sd">    - ``&quot;directions&quot;``: (N, 3) array-like of direction vectors. (optional)</span>
<span class="sd">    - ``&quot;t&quot;`` (optional): float timestamp.</span>
<span class="sd">    - ``&quot;frame_id&quot;`` (optional): string frame identifier.</span>

<span class="sd">    This is consistent with the rest of the LiDAR utilities in this module,</span>
<span class="sd">    which assume a planar LiDAR described by ``ranges`` and ``angles``.</span>

<span class="sd">    :param sample: Raw sample dictionary produced by a sensor stream.</span>
<span class="sd">    :returns: A :class:`LidarMeasurement` instance.</span>
<span class="sd">    :raises KeyError: If required keys are missing from the sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;ranges&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;raw_sample_to_lidar_measurement expected &#39;ranges&#39; in sample&quot;</span><span class="p">)</span>

    <span class="n">ranges</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s2">&quot;ranges&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Determine directions (dirs) if present, else compute from angles if present, else None</span>
    <span class="n">dirs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s2">&quot;directions&quot;</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">:</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s2">&quot;directions&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;angles&quot;</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">:</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s2">&quot;angles&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># Planar lidar: directions in the x-y plane</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">angles</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">LidarMeasurement</span><span class="p">(</span>
        <span class="n">ranges</span><span class="o">=</span><span class="n">ranges</span><span class="p">,</span>
        <span class="n">directions</span><span class="o">=</span><span class="n">dirs</span><span class="p">,</span>
        <span class="n">t</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">frame_id</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;frame_id&quot;</span><span class="p">,</span> <span class="s2">&quot;lidar&quot;</span><span class="p">),</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.conversion.voxel_point_obs_factor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">voxel_point_obs_factor</span><span class="p">(</span><span class="n">voxel_id</span><span class="p">,</span> <span class="n">point_world</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">factor_type</span><span class="o">=</span><span class="s1">&#39;voxel_point_obs&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a single 3D point observation into a voxel-point factor.</p>
<p>This is intended for mapping-style sensors (LiDAR, depth cameras,
RGB-D, stereo) where you receive one or more 3D points in world
coordinates and want to attach them to a voxel cell center.</p>
<p>:param voxel_id: Node id of the voxel variable (<code>voxel_cell</code>)
    in the factor graph.
:type voxel_id: int
:param point_world: Observed 3D point in world coordinates with shape
    <code>(3,)</code>.
:type point_world: jax.numpy.ndarray
:param sigma: Noise level for this observation in world units
    (meters, etc.).
:type sigma: float
:param factor_type: Factor type string (e.g. <code>"voxel_point_obs"</code>)
    corresponding to the voxel-point residual used in your
    measurement model.
:type factor_type: str
:return: A :class:<code>MeasurementFactor</code> describing the voxel-point
    observation.
:rtype: MeasurementFactor</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/conversion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">voxel_point_obs_factor</span><span class="p">(</span>
    <span class="n">voxel_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">point_world</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">factor_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;voxel_point_obs&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MeasurementFactor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a single 3D point observation into a voxel-point factor.</span>

<span class="sd">    This is intended for mapping-style sensors (LiDAR, depth cameras,</span>
<span class="sd">    RGB-D, stereo) where you receive one or more 3D points in world</span>
<span class="sd">    coordinates and want to attach them to a voxel cell center.</span>

<span class="sd">    :param voxel_id: Node id of the voxel variable (``voxel_cell``)</span>
<span class="sd">        in the factor graph.</span>
<span class="sd">    :type voxel_id: int</span>
<span class="sd">    :param point_world: Observed 3D point in world coordinates with shape</span>
<span class="sd">        ``(3,)``.</span>
<span class="sd">    :type point_world: jax.numpy.ndarray</span>
<span class="sd">    :param sigma: Noise level for this observation in world units</span>
<span class="sd">        (meters, etc.).</span>
<span class="sd">    :type sigma: float</span>
<span class="sd">    :param factor_type: Factor type string (e.g. ``&quot;voxel_point_obs&quot;``)</span>
<span class="sd">        corresponding to the voxel-point residual used in your</span>
<span class="sd">        measurement model.</span>
<span class="sd">    :type factor_type: str</span>
<span class="sd">    :return: A :class:`MeasurementFactor` describing the voxel-point</span>
<span class="sd">        observation.</span>
<span class="sd">    :rtype: MeasurementFactor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">point_world</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point_world</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;point_world&quot;</span><span class="p">:</span> <span class="n">point_world</span><span class="p">,</span>
        <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">MeasurementFactor</span><span class="p">(</span>
        <span class="n">factor_type</span><span class="o">=</span><span class="n">factor_type</span><span class="p">,</span>
        <span class="n">var_ids</span><span class="o">=</span><span class="p">(</span><span class="n">voxel_id</span><span class="p">,),</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="sensorsfusion"><code>sensors.fusion</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Sensor fusion utilities for DSG-JIT.</p>
<p>This module provides a small, opinionated <em>fusion core</em> that sits between
raw sensor streams (e.g. LiDAR, cameras, IMUs) and the rest of the
DSG-JIT world/scene-graph stack.</p>
<p>The goals of this layer are:</p>
<ul>
<li>Provide a common abstraction to register named sensors and pull data
  from synchronous streams.</li>
<li>Convert raw samples into strongly-typed measurement objects defined in
  :mod:<code>sensors.camera</code>, :mod:<code>sensors.lidar</code>, and :mod:<code>sensors.imu</code>.</li>
<li>Dispatch the resulting measurements to user-provided callbacks that
  can update a :class:<code>world.model.WorldModel</code> or
  :class:<code>world.dynamic_scene_graph.DynamicSceneGraph</code>.</li>
</ul>
<p>This is intentionally lightweight:</p>
<ul>
<li>It does <strong>not</strong> assume any particular factor-graph structure.</li>
<li>It does <strong>not</strong> run its own background threads or event loops.</li>
<li>It is designed so that experiments can start simple (single-threaded
  polling) while leaving room to grow into a more complex async or
  multi-rate fusion system later on.</li>
</ul>
<p>Typical usage from an experiment::</p>
<pre><code>from sensors.streams import ReadingStream
from sensors.camera import CameraMeasurement
from sensors.lidar import LidarMeasurement
from sensors.fusion import SensorFusionManager

fusion = SensorFusionManager()

# 1) Register a camera and a lidar stream
fusion.register_sensor(
    name="cam0",
    modality="camera",
    stream=ReadingStream(camera_read_fn),
)
fusion.register_sensor(
    name="lidar0",
    modality="lidar",
    stream=ReadingStream(lidar_read_fn),
)

# 2) Connect fusion to the world model via a callback
def on_measurement(meas):
    if isinstance(meas, CameraMeasurement):
        # add a bearing / reprojection factor, etc.
        ...
    elif isinstance(meas, LidarMeasurement):
        # add range factors or occupancy updates
        ...

fusion.register_callback(on_measurement)

# 3) Poll sensors in your main loop
for step in range(100):
    fusion.poll_once()
    # run optimization, render, etc.
</code></pre>
<p>In the future we can add:</p>
<ul>
<li>Async helpers that drive :class:<code>sensors.streams.AReadingStream</code>.</li>
<li>Tighter integration with the dynamic scene graph (e.g. per-agent queues).</li>
<li>Higher-level policies (e.g. downsampling, time sync, etc.).</li>
</ul>










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="sensors.fusion.FusedPoseEstimate" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">FusedPoseEstimate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pose_se3</span><span class="p">,</span> <span class="n">covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source_counts</span><span class="o">=</span><span class="nb">dict</span><span class="p">())</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Fused SE(3) pose estimate produced by SensorFusionManager.</p>
<p>:param t: Time index (discrete step or timestamp) associated with this
    estimate.
:param pose_se3: 6D se(3) pose vector in world coordinates, typically
    <code>(tx, ty, tz, rx, ry, rz)</code>.
:param covariance: Optional 6x6 covariance matrix for the fused pose.
:param source_counts: Optional dictionary tracking how many measurements
    contributed from each sensor type (e.g. <code>{"imu": 10, "lidar": 2}</code>).</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.fusion.RegisteredSensor" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">RegisteredSensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">modality</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Bookkeeping structure for a registered sensor.</p>
<p>:param name: Logical name of the sensor (e.g. <code>"lidar0"</code>).
:param modality: String describing the modality, e.g. <code>"camera"</code>,
    <code>"lidar"</code>, or <code>"imu"</code>. This is used to choose a default
    converter when one is not provided.
:param stream: Underlying sensor stream used to pull raw samples.
:param converter: Function that maps a raw sample from <code>stream</code> to
    a :class:<code>~sensors.base.BaseMeasurement</code> instance.</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.fusion.SensorFusionManager" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">SensorFusionManager</span><span class="p">(</span><span class="n">default_callbacks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">auto_register_world_callbacks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">



        <p>Central registry and dispatcher for sensor measurements.</p>
<p>The fusion manager is intentionally minimal: it owns no threads and does
not know about factor graphs or optimization. It simply:</p>
<ul>
<li>Keeps track of registered sensors.</li>
<li>Polls synchronous streams on demand.</li>
<li>Converts raw samples to measurement objects.</li>
<li>Broadcasts those measurements to user callbacks.</li>
</ul>
<p>Experiments are free to use this in a tight, single-threaded loop, or
to build more advanced async / multi-rate infrastructure on top.</p>
<p>:param default_callbacks: Optional iterable of callbacks to register
    at construction time. Each callback will be called as
    <code>callback(measurement)</code> whenever a new
    :class:<code>~sensors.base.BaseMeasurement</code> is produced.</p>

        <p>Create a new fusion manager.</p>
<p>:param default_callbacks: Optional iterable of callbacks to register
    immediately. Each callback will be invoked as <code>cb(measurement)</code>
    for every measurement produced by :meth:<code>poll_once</code> or
    :meth:<code>push_measurement</code>.
:param world_model: Optional :class:<code>world.model.WorldModel</code> instance
    to be associated with this fusion manager. If provided and
    <code>auto_register_world_callbacks</code> is <code>True</code>, the manager will
    automatically register per-modality callbacks that forward
    measurements into the world model.
:param auto_register_world_callbacks: If <code>True</code> and <code>world_model</code>
    is not <code>None</code>, register default world-model callbacks for
    camera, LiDAR, and IMU measurements (when the corresponding
    handler methods exist on the world model).</p>








                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">default_callbacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">BaseMeasurement</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">world_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;WorldModel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">auto_register_world_callbacks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a new fusion manager.</span>

<span class="sd">    :param default_callbacks: Optional iterable of callbacks to register</span>
<span class="sd">        immediately. Each callback will be invoked as ``cb(measurement)``</span>
<span class="sd">        for every measurement produced by :meth:`poll_once` or</span>
<span class="sd">        :meth:`push_measurement`.</span>
<span class="sd">    :param world_model: Optional :class:`world.model.WorldModel` instance</span>
<span class="sd">        to be associated with this fusion manager. If provided and</span>
<span class="sd">        ``auto_register_world_callbacks`` is ``True``, the manager will</span>
<span class="sd">        automatically register per-modality callbacks that forward</span>
<span class="sd">        measurements into the world model.</span>
<span class="sd">    :param auto_register_world_callbacks: If ``True`` and ``world_model``</span>
<span class="sd">        is not ``None``, register default world-model callbacks for</span>
<span class="sd">        camera, LiDAR, and IMU measurements (when the corresponding</span>
<span class="sd">        handler methods exist on the world model).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_sensors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">RegisteredSensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">BaseMeasurement</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_fused_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_world_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;WorldModel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">world_model</span>

    <span class="k">if</span> <span class="n">default_callbacks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">default_callbacks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_world_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">auto_register_world_callbacks</span><span class="p">:</span>
        <span class="c1"># Automatically hook camera / LiDAR / IMU measurements into the</span>
        <span class="c1"># world model using any available handler methods.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attach_world_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_world_model</span><span class="p">,</span> <span class="n">register_default_callbacks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.fusion.SensorFusionManager.attach_world_model" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attach_world_model</span><span class="p">(</span><span class="n">world_model</span><span class="p">,</span> <span class="n">register_default_callbacks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Attach a :class:<code>world.model.WorldModel</code> to this fusion manager.</p>
<p>When a world model is attached and <code>register_default_callbacks</code> is
<code>True</code>, the manager will install per-modality callbacks that route
camera, LiDAR, and IMU measurements into the world model using any
available handler methods.</p>
<p>Expected handler names on <code>world_model</code> are, for example:</p>
<ul>
<li><code>apply_camera_measurement</code> or <code>add_camera_measurement</code></li>
<li><code>apply_lidar_measurement</code> or <code>add_lidar_measurement</code></li>
<li><code>apply_imu_measurement</code> or <code>add_imu_measurement</code></li>
</ul>
<p>Only handlers that actually exist and are callable will be used.</p>
<p>:param world_model: World model instance to associate.
:param register_default_callbacks: If <code>True</code>, automatically
    register default callbacks that forward measurements into the
    world model.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">attach_world_model</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">world_model</span><span class="p">:</span> <span class="s2">&quot;WorldModel&quot;</span><span class="p">,</span>
    <span class="n">register_default_callbacks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attach a :class:`world.model.WorldModel` to this fusion manager.</span>

<span class="sd">    When a world model is attached and ``register_default_callbacks`` is</span>
<span class="sd">    ``True``, the manager will install per-modality callbacks that route</span>
<span class="sd">    camera, LiDAR, and IMU measurements into the world model using any</span>
<span class="sd">    available handler methods.</span>

<span class="sd">    Expected handler names on ``world_model`` are, for example:</span>

<span class="sd">    * ``apply_camera_measurement`` or ``add_camera_measurement``</span>
<span class="sd">    * ``apply_lidar_measurement`` or ``add_lidar_measurement``</span>
<span class="sd">    * ``apply_imu_measurement`` or ``add_imu_measurement``</span>

<span class="sd">    Only handlers that actually exist and are callable will be used.</span>

<span class="sd">    :param world_model: World model instance to associate.</span>
<span class="sd">    :param register_default_callbacks: If ``True``, automatically</span>
<span class="sd">        register default callbacks that forward measurements into the</span>
<span class="sd">        world model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_world_model</span> <span class="o">=</span> <span class="n">world_model</span>
    <span class="k">if</span> <span class="n">register_default_callbacks</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_register_world_callbacks</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.fusion.SensorFusionManager.get_latest_pose" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_latest_pose</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the most recent fused SE(3) pose estimate, if available.</p>
<p>This is a thin convenience wrapper used by integration layers
(e.g. world models or dynamic scene graphs) to pull a single,
canonical pose update out of the fusion buffer.</p>
<p>:returns: A :class:<code>FusedPoseEstimate</code> instance if any fused result
    has been produced, or <code>None</code> if the manager has not yet
    emitted a pose.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_latest_pose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FusedPoseEstimate</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the most recent fused SE(3) pose estimate, if available.</span>

<span class="sd">    This is a thin convenience wrapper used by integration layers</span>
<span class="sd">    (e.g. world models or dynamic scene graphs) to pull a single,</span>
<span class="sd">    canonical pose update out of the fusion buffer.</span>

<span class="sd">    :returns: A :class:`FusedPoseEstimate` instance if any fused result</span>
<span class="sd">        has been produced, or ``None`` if the manager has not yet</span>
<span class="sd">        emitted a pose.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fused_history</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Assuming you internally store a list of (t, pose, cov, meta).</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">pose_se3</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">source_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fused_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">FusedPoseEstimate</span><span class="p">(</span>
        <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
        <span class="n">pose_se3</span><span class="o">=</span><span class="n">pose_se3</span><span class="p">,</span>
        <span class="n">covariance</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span>
        <span class="n">source_counts</span><span class="o">=</span><span class="n">source_counts</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.fusion.SensorFusionManager.poll_once" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">poll_once</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Poll all registered <em>synchronous</em> streams exactly once.</p>
<p>For each sensor whose stream is an instance of
:class:<code>~sensors.streams.ReadingStream</code>, this method will:</p>
<ol>
<li>Call <code>stream.read()</code> to obtain a raw sample.</li>
<li>If a non-<code>None</code> sample is returned, convert it to a
   measurement via the registered converter.</li>
<li>Dispatch the measurement to all registered callbacks.</li>
</ol>
<p>Asynchronous streams are not handled here; they can be consumed
separately using their own <code>async for</code> loops.</p>
<p>:return: The total number of measurements produced and
    dispatched during this call.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">poll_once</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Poll all registered *synchronous* streams exactly once.</span>

<span class="sd">    For each sensor whose stream is an instance of</span>
<span class="sd">    :class:`~sensors.streams.ReadingStream`, this method will:</span>

<span class="sd">    1. Call ``stream.read()`` to obtain a raw sample.</span>
<span class="sd">    2. If a non-``None`` sample is returned, convert it to a</span>
<span class="sd">       measurement via the registered converter.</span>
<span class="sd">    3. Dispatch the measurement to all registered callbacks.</span>

<span class="sd">    Asynchronous streams are not handled here; they can be consumed</span>
<span class="sd">    separately using their own ``async for`` loops.</span>

<span class="sd">    :return: The total number of measurements produced and</span>
<span class="sd">        dispatched during this call.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">rs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sensors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">stream</span><span class="p">,</span> <span class="n">ReadingStream</span><span class="p">):</span>
            <span class="c1"># Async streams are handled outside of this helper.</span>
            <span class="k">continue</span>

        <span class="n">sample</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">meas</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">converter</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">count</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.fusion.SensorFusionManager.push_measurement" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">push_measurement</span><span class="p">(</span><span class="n">measurement</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Inject a pre-constructed measurement into the fusion pipeline.</p>
<p>This is useful when the experiment already builds measurement
objects directly (e.g. from a simulator) and only wants to reuse
the callback dispatch mechanism.</p>
<p>:param measurement: Measurement instance to dispatch to all
    registered callbacks.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">push_measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measurement</span><span class="p">:</span> <span class="n">BaseMeasurement</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inject a pre-constructed measurement into the fusion pipeline.</span>

<span class="sd">    This is useful when the experiment already builds measurement</span>
<span class="sd">    objects directly (e.g. from a simulator) and only wants to reuse</span>
<span class="sd">    the callback dispatch mechanism.</span>

<span class="sd">    :param measurement: Measurement instance to dispatch to all</span>
<span class="sd">        registered callbacks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">measurement</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.fusion.SensorFusionManager.record_fused_pose" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">record_fused_pose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pose_se3</span><span class="p">,</span> <span class="n">covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Append a fused SE(3) pose estimate to the internal history buffer.</p>
<p>This does not perform any fusion by itself; instead it allows an
external estimator (e.g. an EKF or factor-graph solver) to publish
its current best pose into the fusion manager so that callers can
retrieve it via :meth:<code>get_latest_pose</code>.</p>
<p>:param t: Time index or timestamp associated with the estimate.
:param pose_se3: 6D se(3) pose vector in world coordinates.
:param covariance: Optional 6x6 covariance matrix for the estimate.
:param source_counts: Optional dictionary describing how many
    measurements from each sensor type contributed to this pose.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">record_fused_pose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pose_se3</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">covariance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">source_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append a fused SE(3) pose estimate to the internal history buffer.</span>

<span class="sd">    This does not perform any fusion by itself; instead it allows an</span>
<span class="sd">    external estimator (e.g. an EKF or factor-graph solver) to publish</span>
<span class="sd">    its current best pose into the fusion manager so that callers can</span>
<span class="sd">    retrieve it via :meth:`get_latest_pose`.</span>

<span class="sd">    :param t: Time index or timestamp associated with the estimate.</span>
<span class="sd">    :param pose_se3: 6D se(3) pose vector in world coordinates.</span>
<span class="sd">    :param covariance: Optional 6x6 covariance matrix for the estimate.</span>
<span class="sd">    :param source_counts: Optional dictionary describing how many</span>
<span class="sd">        measurements from each sensor type contributed to this pose.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">source_counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source_counts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_fused_history</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">pose_se3</span><span class="p">,</span> <span class="n">covariance</span><span class="p">,</span> <span class="n">source_counts</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.fusion.SensorFusionManager.register_callback" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">register_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Register a callback to receive all fused measurements.</p>
<p>:param callback: Function that accepts a
    :class:<code>~sensors.base.BaseMeasurement</code> instance. It will be
    called for <em>every</em> measurement produced by
    :meth:<code>poll_once</code> or :meth:<code>push_measurement</code>.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">register_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">BaseMeasurement</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Register a callback to receive all fused measurements.</span>

<span class="sd">    :param callback: Function that accepts a</span>
<span class="sd">        :class:`~sensors.base.BaseMeasurement` instance. It will be</span>
<span class="sd">        called for *every* measurement produced by</span>
<span class="sd">        :meth:`poll_once` or :meth:`push_measurement`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.fusion.SensorFusionManager.register_sensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">register_sensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">modality</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Register a new sensor with the fusion manager.</p>
<p>If <code>converter</code> is not provided, a default converter will be
chosen based on <code>modality</code>.</p>
<p>:param name: Logical sensor name, e.g. <code>"cam0"</code> or <code>"lidar_front"</code>.
:param modality: Modality string (<code>"camera"</code>, <code>"lidar"</code>,
    <code>"imu"</code>, or a custom value). Custom values must provide an
    explicit <code>converter</code>.
:param stream: Sensor stream object used to read raw samples.
:param converter: Optional function that converts raw samples from
    <code>stream</code> into measurement objects.</p>
<p>:raises ValueError: If a sensor with the same name is already
    registered, or if no default converter exists for the given
    modality and no explicit converter is provided.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/fusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">register_sensor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">modality</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">BaseSensorStream</span><span class="p">,</span>
    <span class="n">converter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">BaseMeasurement</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Register a new sensor with the fusion manager.</span>

<span class="sd">    If ``converter`` is not provided, a default converter will be</span>
<span class="sd">    chosen based on ``modality``.</span>

<span class="sd">    :param name: Logical sensor name, e.g. ``&quot;cam0&quot;`` or ``&quot;lidar_front&quot;``.</span>
<span class="sd">    :param modality: Modality string (``&quot;camera&quot;``, ``&quot;lidar&quot;``,</span>
<span class="sd">        ``&quot;imu&quot;``, or a custom value). Custom values must provide an</span>
<span class="sd">        explicit ``converter``.</span>
<span class="sd">    :param stream: Sensor stream object used to read raw samples.</span>
<span class="sd">    :param converter: Optional function that converts raw samples from</span>
<span class="sd">        ``stream`` into measurement objects.</span>

<span class="sd">    :raises ValueError: If a sensor with the same name is already</span>
<span class="sd">        registered, or if no default converter exists for the given</span>
<span class="sd">        modality and no explicit converter is provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sensors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sensor &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is already registered&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">converter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">converter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_default_converter</span><span class="p">(</span><span class="n">modality</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_sensors</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">RegisteredSensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">modality</span><span class="o">=</span><span class="n">modality</span><span class="p">,</span>
        <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
        <span class="n">converter</span><span class="o">=</span><span class="n">converter</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><hr />
<h2 id="sensorsimu"><code>sensors.imu</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Inertial measurement unit (IMU) abstractions and simple integration utilities.</p>
<p>This module provides a small set of IMU-related types and helpers that make
it easy to wire IMU data into DSG-JIT experiments and factor graphs. The
focus is on <strong>structured measurements</strong> and <strong>simple integration</strong>, rather
than on a full production-grade inertial navigation system.</p>
<p>The module typically exposes:</p>
<ul>
<li>
<p><code>IMUMeasurement</code>:
      A lightweight container for a single IMU sample, including body-frame
      linear acceleration, angular velocity, and an associated <code>dt</code> (time
      delta). A timestamp can also be stored for logging or alignment with
      other sensors.</p>
</li>
<li>
<p><code>IMUSensor</code>:
      A thin wrapper around a user-defined sampling function. The sampling
      function returns <code>IMUMeasurement</code> instances, and the wrapper
      provides:
        - A <code>read()</code> method for synchronous polling.
        - An iterator interface for use in simple loops.
        - Compatibility with the generic sensor streaming helpers.</p>
</li>
<li>
<p><code>integrate_imu_naive</code>:
      A toy integrator that demonstrates how to accumulate IMU measurements
      into a position and velocity estimate. It assumes that:
        - Acceleration is already expressed in the world frame, and
        - Gravity has been compensated externally.
      This function is intended for didactic experiments and not as a
      replacement for a full IMU preintegration pipeline.</p>
</li>
</ul>
<p>Usage patterns:</p>
<ul>
<li>Wrap any IMU source (hardware driver, simulator, dataset) with an
    <code>IMUSensor</code> so that you always work with <code>IMUMeasurement</code> objects.</li>
<li>For demonstration or unit tests, use <code>integrate_imu_naive</code> to produce
    rough pose/velocity estimates and then inject those as odometry factors
    into a factor graph.</li>
<li>For more advanced use cases, replace the naive integrator with a
    preintegration module, but keep the same <code>IMUMeasurement</code> and
    <code>IMUSensor</code> interfaces so the rest of the system remains unchanged.</li>
</ul>
<p>The design goal is to make IMU handling:</p>
<ul>
<li>Explicit and transparent (no hidden global state).</li>
<li>Composable with other sensors (cameras, range sensors, etc.).</li>
<li>Easy to plug into the existing DSG-JIT world model and optimization
    stack without requiring changes to core solvers.</li>
</ul>










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="sensors.imu.IMUMeasurement" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">IMUMeasurement</span><span class="p">(</span><span class="n">accel</span><span class="p">,</span> <span class="n">gyro</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Single IMU sample consisting of specific force and angular velocity.</p>
<p>This is a lightweight container for raw IMU readings that can be produced by
hardware drivers, simulators, or log readers and then consumed by the
factor-graph/DSG layers.</p>
<p>The convention assumed here is:</p>
<ul>
<li><code>accel</code> is specific force in the IMU body frame, in <code>m/s^2</code>.</li>
<li><code>gyro</code> is angular velocity in the IMU body frame, in <code>rad/s</code>.</li>
<li><code>dt</code> is the time delta since the previous sample, in seconds.</li>
<li><code>timestamp</code> is an optional absolute time in seconds.</li>
</ul>
<p>:param accel: Linear acceleration in the IMU/body frame, shape <code>(3,)</code>.
:param gyro: Angular velocity in the IMU/body frame, shape <code>(3,)</code>.
:param dt: Time delta since the previous sample, in seconds.
:param timestamp: Optional absolute timestamp in seconds.</p>











<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.imu.IMUMeasurement.as_numpy" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">as_numpy</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the acceleration and gyro as NumPy arrays.</p>
<p>This is a small convenience helper for users who want to interoperate
with NumPy-based tooling. If NumPy is not available, a :class:<code>RuntimeError</code>
is raised.</p>
<p>:return: Tuple <code>(accel_np, gyro_np)</code> as NumPy arrays.
:raises RuntimeError: If NumPy is not installed or import failed.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/imu.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="s2">&quot;np.ndarray&quot;</span><span class="p">,</span> <span class="s2">&quot;np.ndarray&quot;</span><span class="p">]:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the acceleration and gyro as NumPy arrays.</span>

<span class="sd">    This is a small convenience helper for users who want to interoperate</span>
<span class="sd">    with NumPy-based tooling. If NumPy is not available, a :class:`RuntimeError`</span>
<span class="sd">    is raised.</span>

<span class="sd">    :return: Tuple ``(accel_np, gyro_np)`` as NumPy arrays.</span>
<span class="sd">    :raises RuntimeError: If NumPy is not installed or import failed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore[truthy-function]</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;NumPy is not available in this environment.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accel</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gyro</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.imu.IMUSampleFn" class="doc doc-heading">
            <code>IMUSampleFn</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="typing.Protocol">Protocol</span></code></p>



        <p>Protocol for callables that produce :class:<code>IMUMeasurement</code> samples.</p>
<p>This is primarily used to type-annotate IMU sensor wrappers.</p>
<p>:return: A new :class:<code>IMUMeasurement</code> instance.</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.imu.IMUSensor" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">IMUSensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sample_fn</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="sensors.base.BaseSensor">BaseSensor</span></code></p>



        <p>Generic IMU sensor wrapper.</p>
<p>This class adapts any callable that returns :class:<code>IMUMeasurement</code> into the
common sensor interface used by DSG-JIT. It is intentionally minimal: it does
not attempt to manage threads, buffering, or synchronizationâ€”those concerns
are handled by the sensor stream utilities in :mod:<code>sensors.streams</code>.</p>
<p>:param name: Human-readable sensor name.
:param sample_fn: Callable producing a single :class:<code>IMUMeasurement</code> per call.</p>








                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/imu.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sample_fn</span><span class="p">:</span> <span class="n">IMUSampleFn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># ``BaseSensor`` may or may not define an ``__init__``; call it if present.</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="s2">&quot;__init__&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># type: ignore[call-arg]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Fallback if BaseSensor has a different signature.</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># type: ignore[misc]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_sample_fn</span><span class="p">:</span> <span class="n">IMUSampleFn</span> <span class="o">=</span> <span class="n">sample_fn</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.imu.IMUSensor.__iter__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__iter__</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Create an iterator over IMU samples.</p>
<p>This is primarily useful when coupling the sensor with an asynchronous
or synchronous sensor stream helper that consumes an iterator.</p>
<p>:return: Infinite iterator yielding :class:<code>IMUMeasurement</code> objects.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/imu.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">IMUMeasurement</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create an iterator over IMU samples.</span>

<span class="sd">    This is primarily useful when coupling the sensor with an asynchronous</span>
<span class="sd">    or synchronous sensor stream helper that consumes an iterator.</span>

<span class="sd">    :return: Infinite iterator yielding :class:`IMUMeasurement` objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.imu.IMUSensor.read" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">read</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a single IMU measurement.</p>
<p>This will typically perform a blocking read from a hardware device, a
simulator, or a log file, depending on how <code>sample_fn</code> is implemented.</p>
<p>:return: The next :class:<code>IMUMeasurement</code> sample.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/imu.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IMUMeasurement</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read a single IMU measurement.</span>

<span class="sd">    This will typically perform a blocking read from a hardware device, a</span>
<span class="sd">    simulator, or a log file, depending on how ``sample_fn`` is implemented.</span>

<span class="sd">    :return: The next :class:`IMUMeasurement` sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_fn</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="sensors.imu.integrate_imu_naive" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">integrate_imu_naive</span><span class="p">(</span><span class="n">measurements</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Naively integrate IMU measurements to update position and velocity.</p>
<p>This helper performs a very simple, orientation-agnostic integration of a
sequence of IMU samples. It assumes that the acceleration vectors are
already expressed in the world frame and that gravity has been compensated
for. As such, <strong>it is not a replacement for proper IMU preintegration</strong>, but
it is convenient for toy 1D/3D experiments and testing the data flow from
sensors into the optimizer.</p>
<p>The integration scheme is:</p>
<p>.. math::</p>
<pre><code>v_{k+1} &amp;= v_k + a_k \delta t_k\
p_{k+1} &amp;= p_k + v_{k+1} \delta t_k\
</code></pre>
<p>:param measurements: Iterable of :class:<code>IMUMeasurement</code> objects, in time order.
:param v0: Optional initial velocity, shape <code>(3,)</code>. Defaults to zeros.
:param p0: Optional initial position, shape <code>(3,)</code>. Defaults to zeros.
:return: Tuple <code>(p, v)</code> with the final position and velocity.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/imu.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">integrate_imu_naive</span><span class="p">(</span>
    <span class="n">measurements</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">IMUMeasurement</span><span class="p">],</span>
    <span class="n">v0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">p0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Naively integrate IMU measurements to update position and velocity.</span>

<span class="sd">    This helper performs a very simple, orientation-agnostic integration of a</span>
<span class="sd">    sequence of IMU samples. It assumes that the acceleration vectors are</span>
<span class="sd">    already expressed in the world frame and that gravity has been compensated</span>
<span class="sd">    for. As such, **it is not a replacement for proper IMU preintegration**, but</span>
<span class="sd">    it is convenient for toy 1D/3D experiments and testing the data flow from</span>
<span class="sd">    sensors into the optimizer.</span>

<span class="sd">    The integration scheme is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        v_{k+1} &amp;= v_k + a_k \\delta t_k\\</span>
<span class="sd">        p_{k+1} &amp;= p_k + v_{k+1} \\delta t_k\\</span>

<span class="sd">    :param measurements: Iterable of :class:`IMUMeasurement` objects, in time order.</span>
<span class="sd">    :param v0: Optional initial velocity, shape ``(3,)``. Defaults to zeros.</span>
<span class="sd">    :param p0: Optional initial position, shape ``(3,)``. Defaults to zeros.</span>
<span class="sd">    :return: Tuple ``(p, v)`` with the final position and velocity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">v0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">measurements</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas</span><span class="o">.</span><span class="n">accel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">meas</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">v</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="sensorsintegration"><code>sensors.integration</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Helpers for wiring sensor fusion results into DSG-JIT world models.</p>
<p>This module provides small, stateless utilities that take fused pose
estimates from :mod:<code>sensors.fusion</code> and apply them to a
:class:<code>world.model.WorldModel</code> or dynamic scene graph.</p>
<p>By keeping this logic in a separate integration layer, we avoid coupling
the sensor stack directly to the optimization core, while still making it
very easy for users to build real-time or batch pipelines.</p>










<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h2 id="sensors.integration.apply_fused_pose_to_world" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_fused_pose_to_world</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">fusion</span><span class="p">,</span> <span class="n">agent_id</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fused</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Apply a fused SE(3) pose estimate to the world model for a given agent.</p>
<p>If a pose for <code>(agent_id, t)</code> already exists in the world, this function
<strong>updates</strong> its value in-place. Otherwise, it <strong>creates</strong> a new agent pose
variable via :meth:<code>world.model.WorldModel.add_agent_pose</code>.</p>
<p>:param world: World model whose factor graph should be updated.
:param fusion: Sensor fusion manager providing fused pose estimates.
:param agent_id: String identifier for the agent (e.g. <code>"robot0"</code>).
:param t: Discrete timestep index for this update.
:param fused: Optional fused pose estimate. If <code>None</code>, this function
    calls :meth:<code>SensorFusionManager.get_latest_pose</code> internally.
:returns: The integer node id (<code>int(NodeId)</code>) corresponding to the
    agent's pose variable at time <code>t</code>.
:raises ValueError: If no fused estimate is available.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/integration.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_fused_pose_to_world</span><span class="p">(</span>
    <span class="n">world</span><span class="p">:</span> <span class="n">WorldModel</span><span class="p">,</span>
    <span class="n">fusion</span><span class="p">:</span> <span class="n">SensorFusionManager</span><span class="p">,</span>
    <span class="n">agent_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">fused</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FusedPoseEstimate</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a fused SE(3) pose estimate to the world model for a given agent.</span>

<span class="sd">    If a pose for ``(agent_id, t)`` already exists in the world, this function</span>
<span class="sd">    **updates** its value in-place. Otherwise, it **creates** a new agent pose</span>
<span class="sd">    variable via :meth:`world.model.WorldModel.add_agent_pose`.</span>

<span class="sd">    :param world: World model whose factor graph should be updated.</span>
<span class="sd">    :param fusion: Sensor fusion manager providing fused pose estimates.</span>
<span class="sd">    :param agent_id: String identifier for the agent (e.g. ``&quot;robot0&quot;``).</span>
<span class="sd">    :param t: Discrete timestep index for this update.</span>
<span class="sd">    :param fused: Optional fused pose estimate. If ``None``, this function</span>
<span class="sd">        calls :meth:`SensorFusionManager.get_latest_pose` internally.</span>
<span class="sd">    :returns: The integer node id (``int(NodeId)``) corresponding to the</span>
<span class="sd">        agent&#39;s pose variable at time ``t``.</span>
<span class="sd">    :raises ValueError: If no fused estimate is available.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fused</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fused</span> <span class="o">=</span> <span class="n">fusion</span><span class="o">.</span><span class="n">get_latest_pose</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">fused</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No fused pose estimate available to apply to world.&quot;</span><span class="p">)</span>

    <span class="n">pose_vec</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fused</span><span class="o">.</span><span class="n">pose_se3</span><span class="p">)</span>

    <span class="c1"># Check if we already have a pose for this (agent, t).</span>
    <span class="k">if</span> <span class="n">agent_id</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">agent_pose_ids</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">agent_pose_ids</span><span class="p">[</span><span class="n">agent_id</span><span class="p">]:</span>
        <span class="n">nid</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">agent_pose_ids</span><span class="p">[</span><span class="n">agent_id</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
        <span class="n">world</span><span class="o">.</span><span class="n">fg</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">pose_vec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nid</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">add_agent_pose</span><span class="p">(</span><span class="n">agent_id</span><span class="o">=</span><span class="n">agent_id</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pose_vec</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="sensors.integration.apply_trajectory_to_world" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_trajectory_to_world</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">agent_id</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Bulk-apply a discrete trajectory to the world model as agent poses.</p>
<p>This is useful for offline pipelines, where you already have a fused
trajectory (e.g. from a batch fusion run) and simply want to seed or
refresh the world model with those states.</p>
<p>:param world: World model to update.
:param agent_id: String identifier for the agent.
:param trajectory: Mapping from timestep <code>t</code> to 6D se(3) pose vectors
    in world coordinates.
:returns: <code>None</code>. All updates are applied in-place.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/integration.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_trajectory_to_world</span><span class="p">(</span>
    <span class="n">world</span><span class="p">:</span> <span class="n">WorldModel</span><span class="p">,</span>
    <span class="n">agent_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">trajectory</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bulk-apply a discrete trajectory to the world model as agent poses.</span>

<span class="sd">    This is useful for offline pipelines, where you already have a fused</span>
<span class="sd">    trajectory (e.g. from a batch fusion run) and simply want to seed or</span>
<span class="sd">    refresh the world model with those states.</span>

<span class="sd">    :param world: World model to update.</span>
<span class="sd">    :param agent_id: String identifier for the agent.</span>
<span class="sd">    :param trajectory: Mapping from timestep ``t`` to 6D se(3) pose vectors</span>
<span class="sd">        in world coordinates.</span>
<span class="sd">    :returns: ``None``. All updates are applied in-place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">pose_vec</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">pose_vec</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pose_vec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">agent_id</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">agent_pose_ids</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">agent_pose_ids</span><span class="p">[</span><span class="n">agent_id</span><span class="p">]:</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">agent_pose_ids</span><span class="p">[</span><span class="n">agent_id</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
            <span class="n">world</span><span class="o">.</span><span class="n">fg</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">pose_vec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">world</span><span class="o">.</span><span class="n">add_agent_pose</span><span class="p">(</span><span class="n">agent_id</span><span class="o">=</span><span class="n">agent_id</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pose_vec</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="sensorslidar"><code>sensors.lidar</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>LiDAR sensor abstractions and utilities for DSG-JIT.</p>
<p>This module defines a lightweight representation of LiDAR dataâ€”either
1D range scans, 2D planar scans, or sparse 3D point samplesâ€”and provides
a simple, JAX-friendly interface for integrating such scans into the
factor graph or dynamic scene graph layers.</p>
<p>The module includes:</p>
<ul>
<li>
<p><strong>LiDARScan</strong>
      A minimal container representing a single LiDAR measurement:
        - Ranges (1D, 2D, or 3D depending on sensor type)
        - Optional beam angles or directions
        - Optional timestamp
      The structure is intentionally simple so that downstream algorithms
      (e.g., geometry-based localization, place association, or occupancy
      grid inference) can build on top of it without being locked into a
      particular LiDAR model.</p>
</li>
<li>
<p><strong>LiDARSensor</strong>
      A wrapper around any user-provided LiDAR capture function. This allows
      plugging in real hardware, ROS topics, simulation engines, or synthetic
      data generators. The wrapper returns <code>LiDARScan</code> objects and is fully
      compatible with both synchronous and asynchronous streaming utilities.</p>
</li>
<li>
<p><strong>Helper transforms</strong>
      Utilities for:
        - Converting range/angle scans into 2D or 3D point clouds.
        - Projecting LiDAR points into world coordinates given a robot pose.
        - Preparing LiDAR-derived factors for integration into the factor
          graph (e.g., bearing-range residuals, scan-matching constraints).</p>
</li>
</ul>
<p>Design philosophy:</p>
<ul>
<li>Keep the LiDAR model minimal and general.</li>
<li>Allow users to choose how scans translate into DSG elements (places,
    objects, layout nodes, occupancy voxels).</li>
<li>Cleanly interoperate with the broader DSG-JIT world model, enabling:
        - scanâ†’point cloudâ†’place association
        - scanâ†’object detection integration
        - scanâ†’unknown-space discovery
        - scanâ†’range constraints between robot poses and map nodes</li>
</ul>
<p>This module intentionally avoids tying LiDAR data to a specific SLAM method
(e.g., ICP, NDT, LOAM); instead, it provides a consistent base layer for
future plugins and extensions.</p>










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="sensors.lidar.LidarMeasurement" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">LidarMeasurement</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame_id</span><span class="o">=</span><span class="s1">&#39;lidar&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Lightweight container for a single LiDAR scan.</p>
<p>This structure is deliberately minimal and JAX-friendly. It can be used
for 1D range scans, 2D planar scans, or sparse 3D point samples, and
is meant to serve as an intermediate representation between raw sensor
data and DSG-JIT factors (e.g., range/bearing residuals, voxel updates).</p>
<p>:param ranges:
    LiDAR ranges in sensor coordinates.</p>
<pre><code>Typical shapes:

* 1D scan: ``(N,)`` where each entry is a range sample.
* 2D grid: ``(H, W)`` for image-like range sensors.
* Sparse 3D: ``(N,)`` used together with ``directions`` below.

Values are typically in meters.
</code></pre>
<p>:type ranges: jax.numpy.ndarray</p>
<p>:param directions:
    Optional unit vectors giving the direction of each range sample in
    the sensor frame.</p>
<pre><code>Typical shapes:

* 1D scan: ``(N, 3)`` where each row is a 3D direction vector.
* 2D grid: ``(H, W, 3)`` matching the shape of ``ranges``.

If ``None``, downstream code is expected to infer directions based
on sensor intrinsics (e.g., azimuth/elevation tables or a pinhole
camera model).
</code></pre>
<p>:type directions: Optional[jax.numpy.ndarray]</p>
<p>:param t:
    Optional timestamp (e.g., in seconds). This can be used to align the
    measurement with the dynamic scene graph time index or other sensors.
:type t: Optional[float]</p>
<p>:param frame_id:
    Identifier for the sensor frame from which this measurement was
    taken (e.g. <code>"lidar_front"</code>). This is useful when a robot carries
    multiple LiDAR units or when extrinsic calibration is maintained
    per frame.
:type frame_id: str</p>
<p>:param metadata:
    Optional dictionary for any additional information (e.g., intensity
    values, per-beam noise estimates, or scan ID). This field is not
    used by the core library but can be useful for higher-level
    perception algorithms.
:type metadata: Optional[dict]</p>











<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.lidar.RangeSensor" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">RangeSensor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">agent_id</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="dsg_jit.sensors.base.Sensor">Sensor</span></code></p>



        <p>Simple range-only sensor attached to an agent.</p>
<p>Given a :class:<code>SensorReading</code> whose <code>data</code> field is a scalar
range, this sensor produces a single <code>"range"</code> factor connecting
the agent's pose at time <code>t</code> to a 3D target node.</p>
<p>It expects:</p>
<ul>
<li>the agent trajectory to be registered in the
  :class:<code>DynamicSceneGraph</code> under the same <code>agent_id</code> used to
  construct this sensor, and</li>
<li>the target node id to be present in the underlying
  :class:<code>SceneGraphWorld</code>.</li>
</ul>
<p>The factor uses :func:<code>slam.measurements.range_residual</code> and is
registered under the factor type <code>"range"</code>.</p>








                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/lidar.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">agent_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">RangeSensorConfig</span><span class="p">,</span>
    <span class="n">sg</span><span class="p">:</span> <span class="n">SceneGraphWorld</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">agent_id</span><span class="o">=</span><span class="n">agent_id</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span>  <span class="c1"># used to look up the target&#39;s variable index</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.lidar.RangeSensor.build_factors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">build_factors</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">dsg</span><span class="p">,</span> <span class="n">reading</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Build a single range factor from a reading.</p>
<p>:param wm: World model whose factor graph already contains the
    agent poses and the target node declared in the config.
:type wm: world.model.WorldModel
:param dsg: Dynamic scene graph providing the pose node id for
    <code>(agent_id, reading.t)</code>.
:type dsg: world.dynamic_scene_graph.DynamicSceneGraph
:param reading: Range measurement; <code>reading.data</code> is assumed
    to be a scalar float.
:type reading: sensors.base.SensorReading
:return: List containing a single <code>"range"</code> factor.
:rtype: list[core.types.Factor]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/lidar.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_factors</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">wm</span><span class="p">:</span> <span class="n">WorldModel</span><span class="p">,</span>
    <span class="n">dsg</span><span class="p">:</span> <span class="n">DynamicSceneGraph</span><span class="p">,</span>
    <span class="n">reading</span><span class="p">:</span> <span class="n">SensorReading</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Factor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a single range factor from a reading.</span>

<span class="sd">    :param wm: World model whose factor graph already contains the</span>
<span class="sd">        agent poses and the target node declared in the config.</span>
<span class="sd">    :type wm: world.model.WorldModel</span>
<span class="sd">    :param dsg: Dynamic scene graph providing the pose node id for</span>
<span class="sd">        ``(agent_id, reading.t)``.</span>
<span class="sd">    :type dsg: world.dynamic_scene_graph.DynamicSceneGraph</span>
<span class="sd">    :param reading: Range measurement; ``reading.data`` is assumed</span>
<span class="sd">        to be a scalar float.</span>
<span class="sd">    :type reading: sensors.base.SensorReading</span>
<span class="sd">    :return: List containing a single ``&quot;range&quot;`` factor.</span>
<span class="sd">    :rtype: list[core.types.Factor]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">reading</span><span class="o">.</span><span class="n">t</span>
    <span class="n">range_meas</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reading</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Resolve pose node id from the DSG trajectory.</span>
    <span class="n">pose_nid</span> <span class="o">=</span> <span class="n">dsg</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">pose_trajectory</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">agent_id</span><span class="p">,</span> <span class="n">t</span><span class="p">)]</span>

    <span class="c1"># Variable ids: [pose, target]</span>
    <span class="n">var_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">pose_nid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">target_node</span><span class="p">)</span>

    <span class="c1"># Params for range_residual.</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;range&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">range_meas</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">sigma_to_weight</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">noise_sigma</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">factor</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span>
        <span class="nb">id</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">wm</span><span class="o">.</span><span class="n">fg</span><span class="o">.</span><span class="n">factors</span><span class="p">),</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;range&quot;</span><span class="p">,</span>
        <span class="n">var_ids</span><span class="o">=</span><span class="n">var_ids</span><span class="p">,</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">factor</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.lidar.RangeSensorConfig" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">RangeSensorConfig</span><span class="p">(</span><span class="n">noise_sigma</span><span class="p">,</span> <span class="n">target_node</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">



        <p>Configuration for a simple range-only sensor.</p>
<p>:param noise_sigma: Standard deviation of the range measurement, in
    the same units as the world coordinates (typically meters).
:type noise_sigma: float
:param target_node: Node id of the 3D target in the
    :class:<code>SceneGraphWorld</code> (e.g. a room or object center).
:type target_node: int</p>











<div class="doc doc-children">












  </div>

    </div>

</div>




  </div>

    </div>

</div><hr />
<h2 id="sensorsstreams"><code>sensors.streams</code></h2>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Generic sensor streaming utilities for DSG-JIT.</p>
<p>This module provides a unified abstraction layer for handling live or
simulated sensor data streamsâ€”synchronous or asynchronousâ€”so that all
sensor types (IMU, LiDAR, cameras, range sensors, etc.) can plug into
DSG-JITâ€™s dynamic scene graph pipeline without requiring unique logic for
each device.</p>
<p>The key goal is to decouple <strong>how data is produced</strong> (polling, callbacks,
asynchronous feeds) from <strong>how DSG-JIT consumes that data</strong> (factor graph
updates, node creation, temporal linking).</p>
<p>The module typically defines:</p>
<ul>
<li>
<p><strong>SynchronousStreams</strong></p>
<ul>
<li>A minimal wrapper around a sensor object that exposes a <code>read()</code>
    method.</li>
<li>Designed for simple for-loops or offline dataset playback.</li>
<li>Ensures each call returns a typed measurement (e.g., IMUMeasurement,
    CameraFrame, LiDARScan).</li>
</ul>
</li>
<li>
<p><strong>AsynchronousStreams</strong></p>
<ul>
<li>Provides asyncio-based background tasks that fetch sensor data
    without blocking the main SLAM/DSG loop.</li>
<li>Each sensor type is polled in a separate coroutine, and the latest
    measurement is stored internally for consumption.</li>
<li>Enables future real-time extensions (e.g., multi-sensor fusion,
    asynchronous factor graph updates).</li>
</ul>
</li>
<li>
<p><strong>StreamHandle</strong></p>
<ul>
<li>An ergonomic wrapper exposing:
      <code>.latest()</code> â€“ retrieve most recent measurement.
      <code>.reset()</code> â€“ clear buffer.
      <code>.close()</code> â€“ stop background tasks.</li>
<li>Useful for synchronized fusion pipelines where multiple sensors must
    provide data simultaneously.</li>
</ul>
</li>
</ul>
<p>Design philosophy:</p>
<ul>
<li>Treat <em>all</em> sensors uniformlyâ€”same streaming API regardless of modality.</li>
<li>Allow both synchronous and asynchronous execution with zero change to
    downstream SLAM/DSG logic.</li>
<li>Enable future â€œplug-and-playâ€ sensor integration for real robots,
    simulators, prerecorded logs, or unit test data.</li>
</ul>
<p>This module does not itself perform SLAM or scene graph updatesâ€”it only
defines the mechanism by which sensors deliver data into such pipelines.</p>










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="sensors.streams.AsyncFileRangeStream" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">AsyncFileRangeStream</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="AsyncReadingStream (sensors.streams.AsyncReadingStream)" href="#sensors.streams.AsyncReadingStream">AsyncReadingStream</a></code></p>



        <p>Asynchronous file-backed range stream.</p>
<p>This behaves like :class:<code>FileRangeStream</code>, but exposes an async iterator
interface so it can be consumed with <code>async for</code>. An optional <code>delay</code>
can be used to simulate a sensor publishing at a fixed rate.</p>
<p>.. note::</p>
<p>File I/O is still performed using the standard blocking <code>open</code> call.
   For small logs and simple simulations this is usually fine, but for
   large files or strict real-time requirements you may prefer to replace
   this with a true async file reader.</p>
<p>:param path: Path to a text file containing one numeric value per line.
:type path: str
:param delay: Optional delay between consecutive readings, in seconds.
:type delay: float or None</p>

        <p>Initialize the asynchronous file-backed range stream.</p>
<p>:param path: Path to a text file containing one numeric value per line.
:type path: str
:param delay: Optional delay between consecutive readings, in seconds.
:type delay: float or None</p>








                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the asynchronous file-backed range stream.</span>

<span class="sd">    :param path: Path to a text file containing one numeric value per line.</span>
<span class="sd">    :type path: str</span>
<span class="sd">    :param delay: Optional delay between consecutive readings, in seconds.</span>
<span class="sd">    :type delay: float or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.streams.AsyncFileRangeStream.__aiter__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__aiter__</span><span class="p">()</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Asynchronously iterate over sensor readings.</p>
<p>If <code>delay</code> is set, the coroutine sleeps for that many seconds
between consecutive readings.</p>
<p>:return: Asynchronous iterator over :class:<code>SensorReading</code> objects.
:rtype: AsyncIterator[SensorReading]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">SensorReading</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Asynchronously iterate over sensor readings.</span>

<span class="sd">    If ``delay`` is set, the coroutine sleeps for that many seconds</span>
<span class="sd">    between consecutive readings.</span>

<span class="sd">    :return: Asynchronous iterator over :class:`SensorReading` objects.</span>
<span class="sd">    :rtype: AsyncIterator[SensorReading]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: we use regular file I/O here; for most offline logs this is</span>
    <span class="c1"># sufficient and keeps the dependency surface small.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delay</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">SensorReading</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.streams.AsyncReadingStream" class="doc doc-heading">
            <code>AsyncReadingStream</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSensorStream (sensors.streams.BaseSensorStream)" href="#sensors.streams.BaseSensorStream">BaseSensorStream</a></code></p>



        <p>Asynchronous stream of :class:<code>SensorReading</code> objects.</p>
<p>Subclasses implement :meth:<code>__aiter__</code> to provide an async iterator over
sensor readings. This is useful when integrating with an asyncio-based
event loop or real-time sensor drivers.</p>











<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.streams.AsyncReadingStream.__aiter__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__aiter__</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Return an asynchronous iterator over sensor readings.</p>
<p>:return: Asynchronous iterator over :class:<code>SensorReading</code> objects.
:rtype: AsyncIterator[SensorReading]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">SensorReading</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an asynchronous iterator over sensor readings.</span>

<span class="sd">    :return: Asynchronous iterator over :class:`SensorReading` objects.</span>
<span class="sd">    :rtype: AsyncIterator[SensorReading]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.streams.BaseSensorStream" class="doc doc-heading">
            <code>BaseSensorStream</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="abc.ABC">ABC</span></code></p>



        <p>Abstract base class for all sensor streams used by DSG-JIT.</p>
<p>This defines the minimal interface that synchronous and asynchronous
sensor streams must support so they can be registered with
:class:<code>sensors.fusion.SensorFusionManager</code>.</p>
<p>Subclasses may implement <em>either</em> sync or async behavior:</p>
<ul>
<li>Synchronous streams must implement :meth:<code>read</code>.</li>
<li>Asynchronous streams must implement :meth:<code>__aiter__</code>.</li>
</ul>
<p>Implementations may choose to support both, but it is not required.</p>











<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.streams.BaseSensorStream.__aiter__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__aiter__</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Asynchronous iteration interface. Async-only streams MUST implement
this. Sync-only streams may raise <code>NotImplementedError</code>.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Asynchronous iteration interface. Async-only streams MUST implement</span>
<span class="sd">    this. Sync-only streams may raise ``NotImplementedError``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This stream does not support async iteration.&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.streams.BaseSensorStream.close" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">close</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Optional cleanup hook.</p>
<p>Streams that hold system resources (files, sockets, hardware handles)
should override this to release them.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optional cleanup hook.</span>

<span class="sd">    Streams that hold system resources (files, sockets, hardware handles)</span>
<span class="sd">    should override this to release them.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.streams.BaseSensorStream.read" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">read</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the next sample from the stream, or <code>None</code> if no sample
is currently available.</p>
<p>Sync-only streams MUST implement this. Async-only streams may raise
<code>NotImplementedError</code>.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the next sample from the stream, or ``None`` if no sample</span>
<span class="sd">    is currently available.</span>

<span class="sd">    Sync-only streams MUST implement this. Async-only streams may raise</span>
<span class="sd">    ``NotImplementedError``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This stream does not support sync read().&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.streams.FileRangeStream" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">FileRangeStream</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ReadingStream() (sensors.streams.ReadingStream)" href="#sensors.streams.ReadingStream">ReadingStream</a></code></p>



        <p>Synchronous stream backed by a plain-text file.</p>
<p>Each line in the file is interpreted as a single floating-point range
measurement. The line index is used as the time step <code>t</code>.</p>
<p>:param path: Path to a text file containing one numeric value per line.
:type path: str</p>

        <p>Initialize the file-backed range stream.</p>
<p>:param path: Path to a text file containing one numeric value per line.
:type path: str</p>








                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the file-backed range stream.</span>

<span class="sd">    :param path: Path to a text file containing one numeric value per line.</span>
<span class="sd">    :type path: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.streams.FileRangeStream.__iter__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__iter__</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Yield sensor readings from the underlying file.</p>
<p>Each yielded reading has <code>t</code> equal to the zero-based line index and
<code>data</code> equal to the parsed floating-point value.</p>
<p>:return: Iterator over :class:<code>SensorReading</code> objects.
:rtype: Iterator[SensorReading]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">SensorReading</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Yield sensor readings from the underlying file.</span>

<span class="sd">    Each yielded reading has ``t`` equal to the zero-based line index and</span>
<span class="sd">    ``data`` equal to the parsed floating-point value.</span>

<span class="sd">    :return: Iterator over :class:`SensorReading` objects.</span>
<span class="sd">    :rtype: Iterator[SensorReading]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">SensorReading</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.streams.FunctionStream" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">FunctionStream</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ReadingStream() (sensors.streams.ReadingStream)" href="#sensors.streams.ReadingStream">ReadingStream</a></code></p>



        <p>Synchronous stream that pulls samples from a user-provided callback
function instead of a file or iterator.</p>


<details class="the-callback-must-return-either" open>
  <summary>The callback must return either</summary>
  <ul>
<li>a SensorReading</li>
<li>None (to indicate end of data)</li>
</ul>
</details>







                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">












  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="sensors.streams.ReadingStream" class="doc doc-heading">
              <code class="highlight language-python"><span class="n">ReadingStream</span><span class="p">()</span></code>

</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSensorStream (sensors.streams.BaseSensorStream)" href="#sensors.streams.BaseSensorStream">BaseSensorStream</a></code></p>



        <p>Synchronous stream of :class:<code>SensorReading</code> objects.</p>
<p>Concrete subclasses implement :meth:<code>__iter__</code> to yield readings one by one.</p>
<p>Typical usage::</p>
<pre><code>stream = FileRangeStream("ranges.txt")
for reading in stream:
    process(reading)
</code></pre>

        <p>Initialize a new reading stream.</p>
<p>Subclasses typically only need to override :meth:<code>__iter__</code>. This base
constructor sets up internal state for :meth:<code>read</code>.</p>








                  <details class="mkdocstrings-source">
                    <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize a new reading stream.</span>

<span class="sd">    Subclasses typically only need to override :meth:`__iter__`. This base</span>
<span class="sd">    constructor sets up internal state for :meth:`read`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterator</span><span class="p">[</span><span class="n">SensorReading</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
                  </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="sensors.streams.ReadingStream.__iter__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__iter__</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Iterate over sensor readings.</p>
<p>:return: Iterator over :class:<code>SensorReading</code> objects.
:rtype: Iterator[SensorReading]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">SensorReading</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterate over sensor readings.</span>

<span class="sd">    :return: Iterator over :class:`SensorReading` objects.</span>
<span class="sd">    :rtype: Iterator[SensorReading]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="sensors.streams.ReadingStream.read" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">read</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the next sensor reading from the stream, or <code>None</code> if the
underlying iterator is exhausted.</p>
<p>This method adapts the iterator protocol (<code>__iter__</code>) to the
:class:<code>BaseSensorStream</code> synchronous <code>read</code> API, so that
:class:<code>~sensors.fusion.SensorFusionManager</code> and other callers can
treat all synchronous streams uniformly.</p>
<p>:return: Next sensor reading, or <code>None</code> if no further data is
         available.
:rtype: Optional[SensorReading]</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>dsg-jit/dsg_jit/sensors/streams.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SensorReading</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the next sensor reading from the stream, or ``None`` if the</span>
<span class="sd">    underlying iterator is exhausted.</span>

<span class="sd">    This method adapts the iterator protocol (``__iter__``) to the</span>
<span class="sd">    :class:`BaseSensorStream` synchronous ``read`` API, so that</span>
<span class="sd">    :class:`~sensors.fusion.SensorFusionManager` and other callers can</span>
<span class="sd">    treat all synchronous streams uniformly.</span>

<span class="sd">    :return: Next sensor reading, or ``None`` if no further data is</span>
<span class="sd">             available.</span>
<span class="sd">    :rtype: Optional[SensorReading]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><hr />












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.sections", "navigation.tracking", "content.code.annotate", "content.tabs.link", "content.code.copy", "search.highlight", "search.suggest"], "search": "../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
    
  </body>
</html>